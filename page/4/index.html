<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.igiven.com","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="一个不专业的程序员,写着不专业的博客">
<meta property="og:type" content="website">
<meta property="og:title" content="IGiven">
<meta property="og:url" content="http://www.igiven.com/page/4/index.html">
<meta property="og:site_name" content="IGiven">
<meta property="og:description" content="一个不专业的程序员,写着不专业的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="zhepama">
<meta property="article:tag" content="UNITY">
<meta property="article:tag" content="C#">
<meta property="article:tag" content="游戏开发">
<meta property="article:tag" content="NETCORE">
<meta property="article:tag" content="JS">
<meta property="article:tag" content="PHP">
<meta property="article:tag" content="C">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://www.igiven.com/page/4/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>IGiven</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">IGiven</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">一个不专业的程序员,写着不专业的博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">81</span></a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">32</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">4</span></a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.igiven.com/dotnet-2020-02-06-Consistent-Hash/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhepama">
      <meta itemprop="description" content="一个不专业的程序员,写着不专业的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IGiven">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/dotnet-2020-02-06-Consistent-Hash/" class="post-title-link" itemprop="url">一致性hash算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-06 08:00:00" itemprop="dateCreated datePublished" datetime="2020-02-06T08:00:00+08:00">2020-02-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-16 12:44:43" itemprop="dateModified" datetime="2020-07-16T12:44:43+08:00">2020-07-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/dotnet/" itemprop="url" rel="index"><span itemprop="name">dotnet</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p><code>负载均衡</code>和<code>分布式场景</code></p>
<p>随着业务的扩展，流量的剧增，单体项目逐渐划分为分布式系统。对于经常使用的数据，我们可以使用Redis作为缓存机制，减少数据层的压力。因此，重构后的系统架构如下图所示：<br><img src="../../assets/images/2020-02-06-Consistent_Hash/3560038521-5c37267165ddf_articlex.png" alt="简单架构"></p>
<p>优化最简单的策略就是，把常用的数据保存到Redis中，为了实现高可用使用了3台Redis（没有设置集群，集群至少要6台）。每次Redis请求会随机发送到其中一台，但是这种策略会引发如下两个问题：</p>
<ul>
<li>同一份数据可能在多个Redis数据库，造成数据冗余</li>
<li>某一份数据在其中一台Redis数据库已存在，但是再次访问Redis数据库，并没有命中数据已存在的库。无法保证对相同的key的所有访问都发送到相同的Redis中</li>
</ul>
<p>要解决上述的问题，我们需要稍稍改变一些key存入Redis的规则：<strong>使用hash算法</strong><br>例如，有三台Redis，对于每次的访问都可以通过计算hash来求得hash值。<br>如公式 h=hash(key)%3，我们把Redis编号设置成0,1,2来保存对应hash计算出来的值，h的值等于Redis对应的编号。<br>但是hash算法也会面临容错性和扩展性的问题。容错性是指当系统中的某个服务出现问题时，不能影响其他系统。扩展性是指当加入新的服务器后，整个系统能正确高效运行。</p>
<p>现假设有一台Redis服务器宕机了，那么为了填补空缺，要将宕机的服务器从编号列表中移除，后面的服务器按顺序前移一位并将其编号值减一，此时每个key就要按h = Hash(key) % 2重新计算。</p>
<p>同样，如果新增一台服务器，规则也同样需要重新计算，h = Hash(key) % 4。因此，系统中如果有服务器更变，会直接影响到Hash值，大量的key会重定向到其他服务器中，造成缓存命中率降低，而这种情况在分布式系统中是十分糟糕的。</p>
<p>一个设计良好的分布式哈希方案应该具有良好的单调性，即服务节点的变更不会造成大量的哈希重定位。一致性哈希算法由此而生~</p>
<h2 id="2-一致性哈希算法"><a href="#2-一致性哈希算法" class="headerlink" title="2 一致性哈希算法"></a>2 一致性哈希算法</h2><blockquote>
<p>一致哈希 是一种特殊的哈希算法。在使用一致哈希算法后，哈希表槽位数（大小）的改变平均只需要对 K/n 个关键字重新映射，其中K是关键字的数量， n是槽位数量。然而在传统的哈希表中，添加或删除一个槽位的几乎需要对所有关键字进行重新映射。</p>
</blockquote>
<p>简单的说，一致性哈希是将整个哈希值空间组织成一个虚拟的圆环，如假设哈希函数H的值空间为0-2^32-1（哈希值是32位无符号整形），整个哈希空间环如下：</p>
<p><img src="../../assets/images/2020-02-06-Consistent_Hash/1926833502-5c372671647ce_articlex.png" alt="哈希环"><br>整个空间按顺时针方向组织，0和2^32-1在零点中方向重合。</p>
<p>接下来，把服务器按照IP或主机名作为关键字进行哈希，这样就能确定其在哈希环的位置。<br><img src="../../assets/images/2020-02-06-Consistent_Hash/1992706399-5c37267165131_articlex.png" alt="哈希环2"><br>然后，我们就可以使用哈希函数H计算值为key的数据在哈希环的具体位置h，根据h确定在环中的具体位置，从此位置沿顺时针滚动，遇到的第一台服务器就是其应该定位到的服务器。</p>
<p>例如我们有A、B、C、D四个数据对象，经过哈希计算后，在环空间上的位置如下：</p>
<p><img src="../../assets/images/2020-02-06-Consistent_Hash/2362548025-5c3726711599a_articlex.png" alt="哈希环3"><br>根据一致性哈希算法，数据A会被定为到Server 1上，数据B被定为到Server 2上，而C、D被定为到Server 3上。</p>
<h2 id="3-容错性和扩展性"><a href="#3-容错性和扩展性" class="headerlink" title="3 容错性和扩展性"></a>3 容错性和扩展性</h2><p>那么使用一致性哈希算法的容错性和扩展性如何呢？</p>
<h3 id="3-1-容错性"><a href="#3-1-容错性" class="headerlink" title="3.1 容错性"></a>3.1 容错性</h3><p>假如RedisService2宕机了，那么会怎样呢？</p>
<p><img src="../../assets/images/2020-02-06-Consistent_Hash/2142503411-5c37267117f14_articlex.png" alt="Redis2宕机"></p>
<p>那么，数据B对应的节点保存到RedisService3中。因此，其中一台宕机后，干扰的只有前面的数据（原数据被保存到顺时针的下一个服务器），而不会干扰到其他的数据。</p>
<h3 id="3-2-扩展性"><a href="#3-2-扩展性" class="headerlink" title="3.2 扩展性"></a>3.2 扩展性</h3><p>下面考虑另一种情况，假如增加一台服务器Redis4，具体位置如下图所示：</p>
<p><img src="../../assets/images/2020-02-06-Consistent_Hash/1713186145-5c37267126a94_articlex.png" alt="RedisServicee4"><br>原本数据C是保存到Redis3中，但由于增加了Redis4，数据C被保存到Redis4中。干扰的也只有Redis3而已，其他数据不会受到影响。</p>
<p>因此，一致性哈希算法对于节点的增减都只需重定位换空间的一小部分即可，具有较好的容错性和可扩展性</p>
<h2 id="4-虚拟节点"><a href="#4-虚拟节点" class="headerlink" title="4 虚拟节点"></a>4 虚拟节点</h2><p>前面部分都是讲述到Redis节点较多和节点分布较为均衡的情况，如果节点较少就会出现节点分布不均衡造成数据倾斜问题。</p>
<p>例如，我们的的系统有两台Redis，分布的环位置如下图所示：</p>
<p><img src="../../assets/images/2020-02-06-Consistent_Hash/2099070812-5c37267114872_articlex.png" alt="哈希环"><br>这会产生一种情况，Redis4的hash范围比Redis3的hash范围大，导致数据大部分都存储在Redis4中，数据存储不平衡。</p>
<p>为了解决这种数据存储不平衡的问题，一致性哈希算法引入了<strong>虚拟节点机制</strong>，即对每个节点计算多个哈希值，每个计算结果位置都放置在对应节点中，这些节点<strong>称为虚拟节点</strong>。</p>
<p>具体做法可以在服务器IP或主机名的后面增加编号来实现，例如上面的情况，可以为每个服务节点增加三个虚拟节点，于是可以分为 RedisService1#1、 RedisService1#2、 RedisService1#3、 RedisService2#1、 RedisService2#2、 RedisService2#3，具体位置如下图所示：</p>
<p><img src="../../assets/images/2020-02-06-Consistent_Hash/4164216256-5c3726711ca88_articlex.png" alt="虚拟节点"></p>
<p>对于数据定位的hash算法仍然不变，只是增加了虚拟节点到实际节点的映射。例如，数据C保存到虚拟节点Redis1#2，实际上数据保存到Redis1中。这样，就能解决服务节点少时数据不平均的问题。在实际应用中，通常将虚拟节点数设置为<strong>32甚至更大</strong>，因此即使<strong>很少的服务节点</strong>也能做到相对<strong>均匀的数据分布</strong>。</p>
<ul>
<li><a href="https://github.com/tg123/ConsistentSharp" target="_blank" rel="noopener">https://github.com/tg123/ConsistentSharp</a></li>
<li><a href="https://en.wikipedia.org/wiki/Consistent_hashing" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Consistent_hashing</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.igiven.com/tool-2020-02-06-excel-text-number/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhepama">
      <meta itemprop="description" content="一个不专业的程序员,写着不专业的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IGiven">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/tool-2020-02-06-excel-text-number/" class="post-title-link" itemprop="url">Excel中以文本形式存储的数字</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-06 08:00:00" itemprop="dateCreated datePublished" datetime="2020-02-06T08:00:00+08:00">2020-02-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-16 12:44:43" itemprop="dateModified" datetime="2020-07-16T12:44:43+08:00">2020-07-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/tool/" itemprop="url" rel="index"><span itemprop="name">tool</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>在一些特定情况下，单元格中会出现文本形式存储的数字，例如从其他地方复制粘贴过来，或者是较长的数字想要完全显示，设置为文本格式。如果是这样的单元格，在左上角就会有一个绿色小标记。</p>
<p><img src="../../assets/images/2020-02-06-excel/v2-7f8eb44c9239a43b4835c12ba326c2d9_720w.jpg" alt="img"></p>
<p>针对不同需求的单元格，进行数据处理的方式也不同。例如有些数字，在后面是需要进行公式计算的，就可以将单元格从文本转化为普通的数字形式。选中需要修改的单元格，如果在一个区域的话可以选中全部的，然后点击右上角浮动的感叹号，在菜单里面选择“转换为数字”。</p>
<p><img src="../../assets/images/2020-02-06-excel/v2-b825acebee4b0d575dafcbbb9d85079e_720w.jpg" alt="img"></p>
<p>这样一来，单元格格式就会变回常规，绿色小三角也会自动消失。</p>
<p><img src="../../assets/images/2020-02-06-excel/v2-6be2034cecf7128cfdd94adfe2b89d21_720w.jpg" alt="img"></p>
<p>有时候数字较长，例如手机号，也不需要进行公式运算。但是有一个绿色标志，希望去掉，也是可以进行操作的。</p>
<p><img src="../../assets/images/2020-02-06-excel/v2-2b7e7de81faec0a733820a239dbff044_720w.jpg" alt="img"></p>
<p>在菜单中选择“忽略错误”即可，这个绿色小三角就会消失了。</p>
<p><img src="../../assets/images/2020-02-06-excel/v2-2d84b687d6c420607a09f8dd93146b62_720w.jpg" alt="img"></p>
<p>但要注意的是，双击编辑过这个单元格以后，还是会出现绿色小三角标记的错误提示的。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.igiven.com/tool-2020-02-05-game-en-zh/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhepama">
      <meta itemprop="description" content="一个不专业的程序员,写着不专业的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IGiven">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/tool-2020-02-05-game-en-zh/" class="post-title-link" itemprop="url">术语中英文对照</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-05 08:00:00" itemprop="dateCreated datePublished" datetime="2020-02-05T08:00:00+08:00">2020-02-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-16 12:44:43" itemprop="dateModified" datetime="2020-07-16T12:44:43+08:00">2020-07-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/tool/" itemprop="url" rel="index"><span itemprop="name">tool</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>中英对照的网络游戏术语</p>
<p>AC – Armor Class，盔甲等级、级别</p>
<p>Account – 账号，与密码Password相对</p>
<p>Add – 一只玩家加入到组队中，如果请求别人组队，可说Add me pls.</p>
<p>AOE – Area Effect Damage，区域作用魔法，指的是一个可以伤害一个区域中的一群怪物的魔法，即所谓的群攻，现并非魔攻专用</p>
<p>AE – Area Effect，区域作用伤害</p>
<p>AFK – Away from Keyboard，暂时离开(键盘)，意味着玩家暂时不再操控游戏角色，通知其他玩家注意</p>
<p>Aggro – 指一些敌对、主动攻击的怪物，当角色接近它时，它会试图攻击角色，这种行为成为Aggro</p>
<p>Aggro Radius – 怪物周围的区域，进入它意味着怪物会“苏醒”并主动攻击你</p>
<p>Agi – Agility的缩写，意为敏捷，多指代游戏中角色的属性</p>
<p>Avatar – 你的角色，互联网中常用来指头像，如论坛中的会员头像等</p>
<p>Beta – 游戏的测试</p>
<p>Bind(Bound) – 重生复活点</p>
<p>Boss – 游戏中的终极怪物，通常各个级别段都有不同的Boss，中文里可以称为大王，老头儿等</p>
<p>Buff – 主要指辅助类角色为别人施加的有益状态，通俗的说法就是“加状态”，典型的如增加防御、回血速度、躲避率等等</p>
<p>Bug – 游戏中的漏洞</p>
<p>Carebear – 喜欢帮助别人攻击怪物的玩家</p>
<p>Caster – 不能抗怪的角色，如法师</p>
<p>CBT – Closed Beta Test 游戏封闭测试</p>
<p>CD – Cool Down, 多指技能的冷却时间</p>
<p>Character – 游戏中的角色</p>
<p>Cheat – 游戏中的作弊，也只游戏秘笈</p>
<p>Cheese – 利用游戏的不平衡之处牟利</p>
<p>Combat Pets – 被玩家控制的NPC，在战斗中帮助玩家及其队友，直译也有宠物的意思</p>
<p>CR – Corpse Retrevial的缩写，指取回尸体，这要看具体游戏的设置而论，很多游戏没有这个设置</p>
<p>Creep – 怪物</p>
<p>Creep Jacking – 当其他玩家与怪物战斗的时候趁机攻击该玩家</p>
<p>Critters – 面对玩家攻击不会反击的怪物</p>
<p>DD – Direct Damage，直接伤害，非持续性伤害作用</p>
<p>DBUFF – De-Buff的简写，对怪物或敌对玩家施放的具有负面状态，如是对方减速、降低防御、降低准确率等等</p>
<p>Defense – 防御，这是通俗的叫法，具体还有物防、魔防等分类</p>
<p>DKP – Dragon Kill Point的缩写，直译是屠龙点数，一种对玩家贡献的衡量标准</p>
<p>DMG – Damage的缩写，指伤害</p>
<p>DOT – Damage over time，在一段时间内持续对目标造成伤害，持续伤害</p>
<p>DPS – Damage per second的缩写，每秒伤害</p>
<p>Dungeon – 指地宫、地下城等，多指游戏中难度很大的地形，也是Boss的栖居地</p>
<p>FH – Full Health的简写，指生命值全满</p>
<p>FM – Full Mana的简写，指法力全满</p>
<p>Forge – 要塞，可以是游戏中的场景、地图</p>
<p>FS – Full Sport的缩写，指完全负责辅助的角色；汉语里可以做为法师的简称，注意区别</p>
<p>Gank – PvP：当其他玩家与怪物战斗时趁机攻击该玩家，与Creep Jacking 类似</p>
<p>Gate(gateway) – 游戏中的传送，与Portal相似</p>
<p>GM – Game Master的简写，指游戏管理员，服务玩家，维护游戏内正常运行的人</p>
<p>Griefer – 试图骚扰或激怒其他玩家的人</p>
<p>Grinding – 长时间在一地点猎怪，多是为了升级或取得特殊游戏道具</p>
<p>Guild – 公会、团体</p>
<p>Heart – 心脉、血脉，多指游戏角色的属性</p>
<p>HOT – Health Over Time的缩写，指持续性治疗效果</p>
<p>HP – 作为Health point的简写时，指生命值；做为Hit points的简写时指伤害值，其中前者较常用</p>
<p>ID – Identification的简写，网络中表示各种账号，表示账号时，与account意义相同；通常指身份证、证件</p>
<p>INC – Incoming的简写，指引怪的人对其他玩家的警示</p>
<p>Instancing – 游戏中的副本，现在很多网游都引入了这一玩法</p>
<p>INT – Intelligence的简写，指智力，多指代游戏中角色的属性</p>
<p>Item – 泛指游戏内的道具</p>
<p>Kiting – 玩家保持在敌人战斗范围以外的一种战术，从敌人身边跑开，同时对其造成伤害</p>
<p>KO – Knock Out的简写，与人挑战时击败对方</p>
<p>KOS – Killed on Sight的简写，多指游戏中的设置，游戏NPC对敌对阵营玩家的攻击行为</p>
<p>KS – Kill Steal的简写，直译是偷杀，试图杀死另一个人正在对付的怪物，以获取经验(主要目的)、道具(这种情况不多)</p>
<p>Lag – 延时，就是我们平常说的卡，当你卡了，你可以说Laaaaaaaaaag</p>
<p>LFG – Looking for a group的简写，寻找队伍以求加入</p>
<p>LFM – Looking for more的简写，找寻更多的人组队</p>
<p>LOL – Lots of Laugh/Laughing Out Loud的简写，指大笑，很常用的聊天词汇，相当于汉语中的”呵呵”、”哈哈”等，ROFL(笑到打滚)此不常用</p>
<p>LOM – Low on Mana的简写，法力不足</p>
<p>Login – 与Logon, Log-in意义相同，表示登入账号的意思</p>
<p>LOS – Line of Sight的简写，视线</p>
<p>LOOT – 从被杀死的怪物或宝箱里拿取游戏道具、战利品等</p>
<p>Lure – 指引怪，3D游戏中常用，组队杀怪时，有玩家负责将怪引向团队，然后用群攻技能集体杀怪</p>
<p>LVL – Level的简写，游戏角色等级</p>
<p>Maintenance – 维护，一般指游戏停机维护</p>
<p>Mana – 魔法，通俗的称呼是蓝</p>
<p>Map – 地图，游戏内的场景，也可用 Zone 表示地图</p>
<p>Mental – 意念，多指代游戏角色的属性，与下面的Spirit有些类似</p>
<p>Mez – Mesmerize的缩写，指催眠等状态是玩家暂时失去对角色的控制</p>
<p>MMO – Massively Multiplayer Online，大型多人在线</p>
<p>MMOG – Massively Multiplayer Online Game，大型多人在线游戏</p>
<p>MMORPG – Massive Multiplayer Online Role Playing Game，大型多人在线角色扮演游戏</p>
<p>MOB – 指游戏中的怪物，任何怪物都可叫MOB，或游戏中所有由电脑控制的角色，第二种用法不常见</p>
<p>MP – Magic Point魔法值，是对魔法的通俗称呼，正式的叫法应该是Mana</p>
<p>MT – Main Tank的缩写，WOW中的主力抗怪角色，其它游戏中可以没有这样的描述</p>
<p>Muscle – 肌肉，多指游戏角色的属性</p>
<p>Nerf – 消弱</p>
<p>Nerve – 神经，多指游戏角色的属性</p>
<p>Newbie – 菜鸟，形容新玩家，有时也指那些操作不熟练、技术不太好的玩家</p>
<p>Newb – 新人的简称，同上</p>
<p>Ninja – 没有经过相关玩家允许或趁别人没注意而拿走战利品</p>
<p>N00b – 一种用来称呼新人的不礼貌的说法</p>
<p>NPC – Non-Player-Controlled Character，非玩家控制的角色，纯粹的电脑角色，由游戏控制</p>
<p>OBT – Open Beta Test 游戏公开测试</p>
<p>OOM – Out of Mana的简写，法力耗尽，多在组队中提醒队员注意</p>
<p>ORZ – 一个人跪地的无语姿势，象形，表示钦佩的感叹</p>
<p>OT – Over Taunt的缩写，别人的翻译是仇恨失控，怪物对玩家角色的仇恨，多用于WOW中</p>
<p>Party – 组队，与Team相近</p>
<p>Password – 泛指密码</p>
<p>Patch – 补丁</p>
<p>PC – Player controlled character，玩家控制的角色，与上面的NPC是相对的；网络中PC也很常见，指个人电脑</p>
<p>Pet – 被玩家控制的非玩家生物，如宠物、召唤物等</p>
<p>PK – Player Kill或Player Killer，玩家在未经另一个玩家同意的情况下攻击并试图杀死他</p>
<p>Player – 玩家，操作游戏中角色的人</p>
<p>PM – Personal Message的缩写，指一个玩家对另一玩家的私人会话</p>
<p>POP – Repopulation的缩写，指怪物刷新</p>
<p>Portal – 泛指游戏内的传送</p>
<p>Proc – 激活，多指一些武器、装备附加效果、属性</p>
<p>PST – Please Send Tell的简写，指说话的人想通过 /t(ell) 或 /w(hisper) 命令交流</p>
<p>Puller – 负责吸引怪物的玩家，常说引怪，与上面的Lure相近</p>
<p>Pulling – 队伍中的玩家负责吸引一只或几只怪物，并将他们带到队伍所在地，集体杀怪，这多指高级怪物的情况下，与上面的Lure不完全一样</p>
<p>PvE – Player vs. Environment的简写， 玩家与电脑控制的角色战斗</p>
<p>PVP – Player vs. Player的简写，玩家对玩家的战斗</p>
<p>Raid – 可译为突袭，由一群玩家在某一地区进行的大规模作战，有时也指团队副本、大副本</p>
<p>Quest – 游戏中的任务</p>
<p>Re-buff – 重新加有益状态</p>
<p>Res – Resurrect / Rescure的缩写，指复活暂时死亡的角色</p>
<p>Re-Spawn – 一只被杀死的怪物重新刷出</p>
<p>Rest (state) – 角色疲劳状态，一般杀怪经验、物品掉率效率都受影响，是为了玩家健康而强制执行的一项措施</p>
<p>Resistance – 对属性攻击的抵御(如，冰ice, 火fire, 点lighting, 毒poison等)</p>
<p>Respawn – 重生点复活</p>
<p>Roll – 指掷随机数字来决定物品的归属</p>
<p>Root – 给敌人施加的类似定身的状态</p>
<p>Schedule – 泛指游戏内活动的日程表</p>
<p>Sever – 服务器，与游戏客户端相对</p>
<p>Small Pets – 跟随玩家的小动物，可以称为宠物，是否直接影响玩家或怪物，要看具体的游戏设置了</p>
<p>SOLO – 单独杀怪、做任务等，不与别人组队的游戏玩法</p>
<p>Spawns – 在游戏世界中，怪物被刷出时所位于的地点或出现的过程</p>
<p>SPI – Spirit的简写，直译是灵魂，多指代游戏角色的属性</p>
<p>STA – Stamina的缩写，耐力</p>
<p>Stack – 堆放在同一个道具栏中的同类物品的数量，通俗讲就是叠加数量</p>
<p>STR – Strength的缩写，力量，多指代游戏角色的属性</p>
<p>Stun – 击晕(状态)</p>
<p>Tank – 能够承受很多伤害的近战角色，如一名战士，是抗怪的角色</p>
<p>Tap – 对怪物造成伤害，标为你的猎物，一旦你对怪物造成了伤害，只有你才能得到经验值和掠夺战利品</p>
<p>Taunt – 直译是嘲弄的意思，指从其它玩家那里吸引怪物</p>
<p>Team – 游戏内指组队，与Party相近；当用于游戏公司时指(游戏研发、运营)团队</p>
<p>Threat – 直译是威吓的意思，有可能是指将怪物暂时镇住、吓走等</p>
<p>TPP – Third Party Programme，直译为第三方程序，就是平常的外挂</p>
<p>Train – 把一群怪物引向另一名玩家，通俗讲就是陷害</p>
<p>Twink – 高等级带练低等级玩家</p>
<p>&Uuml;ber – super的德语说法，原意指over power, 极其强力</p>
<p>UC – Undercity 地下城</p>
<p>Update – 与Upgrade意义相近，泛指游戏内的更新，如服务器更新、地图更新、道具更新等等</p>
<p>Vendor Trash – 只有商人NPC才愿意购买的物品</p>
<p>VS – Ver Sus的简写，对决、挑战、单挑</p>
<p>WTB – Wanting to buy的缩写，想要购买</p>
<p>WTS – Wanting to sell的缩写，想要出售</p>
<p>XP or Exp – Experience的简写，经验值</p>
<p>3D Accelerator：3D加速器。一种专门提升PC的3D运算功能硬件，但其不能提升计算</p>
<p>机整体的显示效果。</p>
<p>A</p>
<p>ACT（Action Game）：动作类游戏。这类游戏提供玩者一个训练手眼协调及反应力的</p>
<p>环境及功能，通常要求玩者所控制的主角（人或物）根据周遭情况变化做出一定的动</p>
<p>作，如移动、跳跃、攻击、躲避、防守等，来达到游戏所要求的目标。此类游戏讲究逼</p>
<p>真的形体动作、火爆的打斗效果、良好的*作手感及复杂的攻击组合等等。</p>
<p>AI（Artificial Intelligence）：人工智能。就是指计算机模仿真实世界的行为方式</p>
<p>与人类思维与游戏的方式的运算能力。那是一整套极为复杂的运算系统与运算规则。</p>
<p>Alpha：Alpha测试。就是指在游戏制作者控制的环境下进行的游戏测试工作，所以一</p>
<p>般来说a测试是在公司内部进行的。</p>
<p>AVG（Adventure Game）：冒险类游戏。这类游戏在一固定的剧情或故事下，提供玩者</p>
<p>一个可解谜的环境及场景，玩者必须随着故事的安排进行解谜。游戏的目的是借游戏主</p>
<p>角在故事中所冒险积累的经验来解开制作者所设定的谜题或疑点。通常这类游戏常被用</p>
<p>来设计成侦探类型的解谜游戏。</p>
<p>B</p>
<p>Beta：Beta测试。就是指不在制作者控制的环境下进行的游戏测试工作，所以一般来</p>
<p>说Beta测试则是交由选定的测试者单独来进行测试。</p>
<p>Boss：大头目，也称“老板”。在游戏中出现的较为巨大有力与难缠的敌方对手。一</p>
<p>般这类敌人在整个游戏过程中只会出现一次，而常出现在关底，而不像小怪物在游戏中</p>
<p>可以重复登场。</p>
<p>Bug：程序漏洞，俗称“臭虫”。指那些因游戏设计者与测试者的疏漏而剩留在游戏中</p>
<p>的程序错误，严重的话将影响整个作品的质量。</p>
<p>C</p>
<p>Cheat：游戏秘技。游戏设计者暗藏在作品中的特殊技巧，使用后可带给玩者特殊的能</p>
<p>力与效果。最先是程序者为快速测试作品而设计的内部秘技，现在几乎已是每个游戏均</p>
<p>有秘技。</p>
<p>Clock Speed： 游戏执行速度。即游戏在计算机中被运行的速度，常以Megahertz</p>
<p>（MHz）计量。</p>
<p>Code：密码。1）同Cheat条；2）同Source Code条。</p>
<p>D</p>
<p>Doom-like： 三维射击类游戏。即第一人称射击类游戏。游戏画面即为玩者的视野范</p>
<p>围。现在此类游戏多称作Quake-like。</p>
<p>E</p>
<p>E3（Electronic Entertainment Expo）：美国E3大展。 当前世界上最为盛大的电脑</p>
<p>游戏与电视游戏的商贸展示会，基本于每年五月举行。</p>
<p>Easter Egg：复活节彩蛋。 程序中隐藏着的一段意外的内容，常为制作者设计的搞笑</p>
<p>内容，经常是关于制作者自己的介绍与调侃。</p>
<p>ECTS（European Computer Trade Show）：欧洲计算机商贸展示会。被称为欧洲的E3</p>
<p>大展，每年三月和九月于伦敦举行。</p>
<p>Electronic Game：电子游戏。即电脑游戏、电视游戏以及街机和手掌型游戏机的总</p>
<p>称。</p>
<p>Engine：游戏引擎。 即一套游戏的主程序。</p>
<p>Experience Point：经验点数。常出现在角色扮演游戏中，以数值计量人物的成长，</p>
<p>经验点数达到一定数值后常常会升级，这时人物就会变得更强大。</p>
<p>F</p>
<p>FTG（Fighting Game）：格斗类游戏。从动作类游戏脱胎分化出来，就是指两个角色</p>
<p>一对一决斗的游戏形式。现在此类游戏又分化出2D格斗类游戏与3D格斗类游戏。</p>
<p>First Person：第一人称视角。就是指屏幕上不直接出现主角，而是表现为主角的视</p>
<p>野范围。</p>
<p>Flight Sim：飞行模拟类游戏。是模拟类游戏下的一个门类，让玩家感受到*纵飞机以</p>
<p>及飞翔于蓝天上的乐趣。</p>
<p>FMV （Full-motion Video）：全动态影像。即游戏的片头、过场和片尾的动态画面。</p>
<p>Forward Scrolling：向前卷轴。即背景不断向玩者趋近的卷轴模式，常出现在第一人</p>
<p>称射击或模拟类游戏。</p>
<p>Frame：帧，镜头。即显示画面的动态计量单位。</p>
<p>FPS（Frames Per Second）：每秒显示帧数。美国的标准NTSC的电视节目的每秒显示</p>
<p>帧数为30。不少电脑游戏的显示帧数都超过了这个数字。</p>
<p>Free Guy：额外的命。在游戏中，你有可能会获得的额外的命，比如收集一定数量的</p>
<p>某种宝物。</p>
<p>G</p>
<p>Game Over：游戏结束。这是游戏中最常见的话语，通常是表示游戏者失败，而不是通</p>
<p>关爆机。</p>
<p>Gameplay：游戏可玩性。即游戏的玩法，是决定一个游戏有多好玩的重要因素。</p>
<p>Genre：游戏类型。即为不同游戏玩法的游戏作一归类，比如角色扮演类、冒险类、动</p>
<p>作类、模拟类等。</p>
<p>GPU （Graphics Processing Unit）： 图形处理器。辅助CPU处理图形运算。</p>
<p>Graphics Accelerator：图形加速器。专门的提升显示速度和效果的硬件。</p>
<p>Graphic Adventure：图形冒险类游戏。是冒险类游戏下的一个门类， 相对与文字冒</p>
<p>险类游戏。</p>
<p>GUI（Graphical User Interface）：图形用户界面。 即计算机与用户的交互界面。</p>
<p>H</p>
<p>Hidden Level：隐藏关卡。指游戏中隐藏的部分，自行发现。即不玩到这部分也能够</p>
<p>通关，但玩到后可能会使清洁起变化。</p>
<p>High-Res：高解析度。 即精细的画面显示模式，但游戏的运行速度可能会因此有所下</p>
<p>降。</p>
<p>Hint：攻略提示。简单的攻关提示，帮助玩家解决游戏中出现的特别棘手的难题。</p>
<p>HP（Hit Point）：生命力。即人物或作战单位的生命数值。一般HP为0即表示死亡，</p>
<p>甚至Game Over。</p>
<p>HUD（Heads Up Display）：飞行仪表盘。飞行模拟游戏中的常见词，常提供玩家诸如</p>
<p>弹药状况、速度、目标跟踪等作战信息。</p>
<p>I</p>
<p>Interactive Movie：交互式电影。即结合游戏要素与电影要素的一类计算机互动作</p>
<p>品，常常包含大量的FMV（全动态影像）。</p>
<p>Interface：游戏界面。即玩者*作游戏的方式。它决定游戏的上手难度与可玩性。</p>
<p>J</p>
<p>Joypad：游戏手柄。模拟电视游戏的手柄，通常外接在声卡上。</p>
<p>Joystick：游戏<em>纵杆。常用来玩飞行、赛车等模拟类游戏的外接</em>纵杆。</p>
<p>K</p>
<p>L</p>
<p>Level：关卡。即游戏一个连续的完整的舞台、场景。有时也称作Stage。</p>
<p>Low-Res：低解析度。即粗糙的画面显示模式，但运行速度可稍微提高。</p>
<p>M</p>
<p>Motion Capture：动态捕捉。将物体在3D环境中运动的过程数字化的过程。</p>
<p>Motion Tracker：动作跟踪器。动态捕捉时使用到的设备。</p>
<p>Moves：出招。即格斗游戏中人物的出招技巧。</p>
<p>MP（Magic Point）：魔法力。即人物的魔法数值，一旦使用完即不能再使用魔法招</p>
<p>式。</p>
<p>MUD（Multi-user Dungeon）：多用户地牢，俗称“泥巴”。在互联网络上的一种允许</p>
<p>多人参与的实时游戏，一般类似RPG的玩法，但目前多为文字模式。</p>
<p>Multimedia：多媒体。主要指融合多种表现手法的电脑作品。比如FMV（全动态影</p>
<p>像），电脑游戏、交互作品等。</p>
<p>N</p>
<p>Network Games：网络游戏。指容许多人通过某种网络协议连线后便能进行集体游戏的</p>
<p>游戏种类。</p>
<p>NPC（Non Player Character）：非玩者人物。在角色扮演游戏中，玩者会在游戏过程</p>
<p>中遭逢到的所有不受控制的人物。这些人物或会提示重要情报线索，或是无关紧要的人</p>
<p>物。</p>
<p>O</p>
<p>P</p>
<p>Password：过关密码。在游戏一开始处输入后便能直接进入后面的关卡。</p>
<p>Pirate：盗版游戏。即国内到处泛滥令游戏制作公司头痛不已的盗版游戏。</p>
<p>Pixel：像素。屏幕显示的最小基本单位。</p>
<p>Platformer：游戏平台。游戏运行的平台，包括Win95、DOS或者UNIX等。</p>
<p>Player Killing：玩者杀手。指在MUD中，专以攻击玩者人物，而不是非玩者人物的一</p>
<p>类玩家。</p>
<p>Polygon：多角形。运用在2D屏幕中表现3D环境的多角形单位。</p>
<p>Prototype：原型制作。游戏作品的原型制作也就是指以最快的速度制作出游戏的原</p>
<p>型，一个可以执行的程序原型。从这些基础程序与基础图形，制作者可以看到从电脑中</p>
<p>表现出来的与原来设想的有多大差距，经过调整磨合后就进入了正式动工了。</p>
<p>Puzzle：谜题。在冒险类游戏中，考验玩者智力的谜题。</p>
<p>PZL（Puzzle Game）：解谜类游戏。一类专以不断解谜为主要内容的游戏种类。</p>
<p>Q</p>
<p>Quake-like：三维射击类游戏。即第一人称射击类游戏。见Doom-like条。</p>
<p>R</p>
<p>Round：回合。格斗类游戏中的一个较量的回合。</p>
<p>RPG（Role Playing Game）：角色扮演类游戏。这类游戏提供玩者一个可供冒险的世</p>
<p>界（Fantasy World）或者一个反映真实的世界（Real World），这世界包含了各种角</p>
<p>色、建筑、商店、迷宫及各种险峻的地形。玩者所扮演的主角便在这世界中通过旅行、</p>
<p>交谈、交易、打斗、成长、探险及解谜来揭开一系列的故事情节线索，最终走向胜利的</p>
<p>彼岸。玩者依靠自身的胆识、智慧和机敏获得一次又一次的成功，使自己扮演的主角不</p>
<p>断发展壮大，从而得到巨大的精神满足。</p>
<p>RTS（Realtime Strategy Game）： 即时战略类游戏。对应回合制战略游戏，一切都</p>
<p>是实时发生，要求玩者具备较好的敏捷与宏观指挥能力。</p>
<p>S</p>
<p>Scaling：缩放比例。有些游戏提供画面的缩放比例的调整。</p>
<p>Second Person：第二人称视角。即追尾视角，紧随游戏主角的背影。</p>
<p>Shareware Software：共享软件作品。</p>
<p>Side-Scrolling：横向卷轴。即游戏画面的前景与背景从左向右移动的卷轴模式，常</p>
<p>用于2D射击游戏中。</p>
<p>SLG（Simulation Game）：模拟类游戏。这类游戏提供玩者一个可以做逻辑思考及策</p>
<p>略、战略运用的环境，且让玩者有自由支配、管理或统御游戏中的人、事或物的权力，</p>
<p>并通过这种权力及谋略的运用达成游戏所要求的目标。玩者在条件真实、气氛宏大的游</p>
<p>戏环境中充分施展智慧，克敌制胜，达到高层次的成功享受。</p>
<p>Source Code：原代码。用计算机语言直接编成的程序原码，比如C语言、Pascal。</p>
<p>SPT（Sport）：运动类游戏。这类游戏提供一个反映现实（指正常的运动方式及运动</p>
<p>精神）中的运动项目，并让玩者借助控制或管理游戏中的运动员或队伍，来进行运动项</p>
<p>目的比赛。</p>
<p>Stage：关卡。见Level条。</p>
<p>STG（Shooting Game）：射击类游戏。有平面射击类与三维射击类（即第一人称射击</p>
<p>类）。平面射击类还包括横向卷轴与纵向卷轴两种。射击类游戏是早期电脑游戏最常见</p>
<p>的种类。</p>
<p>Storyline：剧情。即游戏的故事大纲，分为直线型、多线型以及开放型等三种。</p>
<p>Strategy Guide：战略指南手册。即游戏包装盒内附有的基本战略指导手册。</p>
<p>Sub-boss：隐藏头目。有些游戏中会隐藏有更厉害的大头目，通常是在通关后。</p>
<p>T</p>
<p>TAB（Table）：桌面类游戏。这类游戏提供一个训练逻辑思考或解谜的环境，并且有</p>
<p>一定的规则及逻辑。玩者必须遵循游戏所设定的规则来解开谜题，达成游戏目标。此类</p>
<p>游戏讲究高超的人工智能、新奇的玩法和舒适的*作环境。玩者在游戏中自得其乐、逍</p>
<p>遥自在，也是一番享受。</p>
<p>TBS（Turn-based Strategy Game）：回合制战略游戏。对应即时战略类游戏。参加战</p>
<p>斗的几方，可以包括计算机在内，依一定顺序分别部署战略。一次部署便称作一个回</p>
<p>合。</p>
<p>Tester：游戏测试者。游戏制作公司专门花钱聘请的测试作品的资深玩家。</p>
<p>Text Adventure：文字冒险类游戏。是冒险类游戏下的一个门类， 相对与图形冒险类</p>
<p>游戏，多是日本制作的小成本卡通游戏。</p>
<p>Third Person：第三人称视角。电脑游戏中最常见的视角，尤其是2D游戏。玩者是以</p>
<p>第三者的角度观察场景与主角的动作。</p>
<p>U</p>
<p>V</p>
<p>Vertically Scrolling：垂直卷轴。即游戏画面的前景与背景从向下向上移动的卷轴</p>
<p>模式，常用于2D射击游戏中。</p>
<p>View：视角。目前许多3D游戏均提供多视角调整功能。</p>
<p>VR （Virtual Reality）：虚拟实境。</p>
<p>W</p>
<p>Walkthrough：游戏攻略。是指完整的游戏攻关指导。</p>
<p>X</p>
<p>Y</p>
<p>Z</p>
<p>Z-line/Z-axis：Z轴。在3D环境中，Z轴一般表示深度，X轴表示高度，Y轴表示宽度，</p>
<p>而具备了Z轴就构成了3D环境。</p>
<p>WOW九大职业：<br>法师mage 战士warriop 德鲁依 drvid 撒满shamam 圣骑士 paladin 术士warlock 盗贼rogue 牧师prisst 猎人 hunter </p>
<p>角色基本术语：</p>
<p>  　　AR——AttackRating攻击准确率</p>
<p>  　　Blocking——ChanceOfBlocking搁挡机率</p>
<p>  　　bloodrun——就是杀怪物，吸取经验值了。一般特指在act5出门之后第一个砍人的地方，叫BloodyFoothills。HC玩家经常在那里升级，比牛关更安全。</p>
<p>  　　CB——CrushingBlow压碎性打击</p>
<p>  　　CE——coldenhanched冰冷强化</p>
<p>  　　Char——Character角色</p>
<p>  　　CR——coldresist冰冷抵抗力</p>
<p>  　　dam——Damage伤害值</p>
<p>  　　Def/DR——Defencerating防御度</p>
<p>  　　DEX——dexterity敏捷度</p>
<p>  　　Dr——damagereduce物理伤害减少(物免)</p>
<p>  　　DS——DeadlyStrike致命攻击</p>
<p>  　　Dualleech——(life，mana)双吸</p>
<p>  　　ED——EnhanchedDamage/EnhanceDefense增强伤害/增强防御(多指前者)</p>
<p>  　　Eng/Erg/Nrg——energy能量/精力</p>
<p>  　　Eth——Ethereal/ethrune无形的(物品)/第五号符文，有将目标Defense防御力降至负值的Bug效果，常镶在武器上。</p>
<p>  　　Exp/XP——Experiencepoint经验值</p>
<p>  　　FBR——fastblockingrate快速格挡机率</p>
<p>  　　FCR——Fastcastrate快速施法率</p>
<p>  　　Fr/w——Fastrun/walk快速奔跑/行走</p>
<p>  　　FHR——Fasthitrecover快速打击恢复</p>
<p>  　　FR——fireresist火焰抵抗力</p>
<p>  　　FE——fireenhanched火焰强化</p>
<p>  　　HP——HitPoints生命值(life)</p>
<p>  　　IAS——IncreasedAttackSpeed提升攻击速度。繁体中文版误译成提升xx%的准确率，繁体中文版的改良补丁有修正。</p>
<p>  　　ITD——IgnoresTarget‘sDefense忽视目标防御</p>
<p>  　　KB——Knockback击退</p>
<p>  　　LE——lightningenhanched闪电强化</p>
<p>  　　Leecher吸血鬼，就是汲取他人的XP来达到足够的clvl，相信大家都做过Leecher吧</p>
<p>  　　life生命值又称：HitPoints(HP)</p>
<p>  　　lightningenhanchedmultishot闪电强化兼多重射击(祈祷你别碰上吧@-@)</p>
<p>  　　LR——lightningresist闪电抵抗力</p>
<p>  　　mana法力值</p>
<p>  　　mod——itemmodifier(prefixesandsuffixes)物品属性(前缀及后缀)</p>
<p>  　　MF——MagicFind魔法物品找寻</p>
<p>  　　Newbie——就是你了(新手)</p>
<p>  　　NPC——Nonplayercharacter非玩家角色</p>
<p>  　　PD——poisondamage毒素伤害(骗点？@_@)</p>
<p>  　　PI——Physicalimmune物理免疫</p>
<p>  　　PR——poisonresist毒素抵抗力</p>
<p>  　　Req——Required/Requirement需求</p>
<p>  　　res——Resistance元素抵抗(四防)</p>
<p>  　　slvl——Skilllevel技能等级</p>
<p>  　　stamina耐力值</p>
<p>  　　STR——strength强壮度/力量</p>
<p>  　　TP——TownPortal/Teleport城镇传送之门/傳送(女巫技能)</p>
<p>  　　UnID——Unidentify未鉴定</p>
<p>  　　VIT——vitality活力/体力值</p>
<p>  　　WP——Waypoint传送小站</p>
<p>  　　XP/Exp——Experiencepoint经验值</p>
<p>  　　增补术语：</p>
<p>  　　BOT——英文Robot的简写，通指各种自动机器人的游戏外挂，譬如KPBOT(自动KP机器人)，SHOPBOT(自动购物机器人)</p>
<p>  　　Dupe——英文duplicate的简写，指复制的装备</p>
<p>  　　Legit——合法物品，指从游戏中真真生成的非Dupe物品(包括BOT打出的物品)，交易用语</p>
<p>  　　Ith——某种利用hack工具制造的Bug物品,多为武器，具有极为变态的伤害值及属性</p>
<p>  　　cg——ChippedGem碎裂的宝石</p>
<p>  　　pg——PerfectGem完美的宝石</p>
<p>  　　PT——PerfectTopaz完美的黄宝石</p>
<p>  　　Jewels——珠宝</p>
<p>  　　Rune——符文</p>
<p>  　　SC——smallcharm小护身符，一般特指7%MF的smallcharm</p>
<p>  　　LC——LargeCharms大型护身符</p>
<p>  　　GC——GrandCharms超大型护身符</p>
<p>  　　cube——TheHoradriccube赫拉迪克方块，常做动词用，指用Cube转化或合成物品的行为</p>
<p>  　　Craft——指物品的手工合成，即其英文原意</p>
<p>  　　MBow——MatriarchalBow女族長之弓，用做DIY合成Curel蓝色Bow的材料，要求其Ilvl物品等级&gt;87。</p>
<p>  　　N‘sc或B‘sc——通指Hell的Baal巴爾(怪物等级Mlvl=95)、Nihlathaks尼塞拉克(怪物等级Mlvl=98)掉出的SC。整个游戏中只有这二位老大出产的SC才可能合出那几种高元素或毒伤害前缀的SC(其Ilvl≥95)。Baal巴爾、Nihlathaks尼塞拉克掉出的GC没什么特别用处。</p>
<p>  　　Diadem權冠——6PerfectSkulls合成RareCirclets稀有头缳用的材料，因为Diadems总能保持Alvl99，能够合出任何可能的词缀。亮黄的RareDiadem或白色的Diadem(可以利用Imbue任务将之造成亮黄的)都可以用做材料。</p>
<p>  　　Clvl—Characterlevel角色等级，很简单的概念，就是指玩家自己角色的级别</p>
<p>  　　Mlvl——MonsterLevel怪物等级，游戏代码中对三个难度的每一个怪物都有固定的等级设定。普通怪物从1-90级，champions，bosses，SuperUniques相对其同类型的普通怪物会加几个等级。譬如Hell的Baal巴爾其怪物等级Mlvl=95、Nihlathaks尼塞拉克其怪物等级Mlvl=98，它们能够出产Cube用的N‘sc。</p>
<p>  　　Ilvl——ItemLevel物品等级，也就是不少玩家俗称的物品内部等级；它是一个变动的数字，其数值就等于各游戏难度掉落该物品的怪物(或者箱子)等级(Mlvl-MonsterLevel)；目前的新版地图都具有了显示怪物等级的功能，省了大家再去翻看资料了。唯一要注意的是不要把怪物等级(Mlvl-MonsterLevel)和怪物所属的的TC-TreasureClass(财宝阶层)混淆</p>
<p>  　　TC——TreasureClass财宝阶层，游戏中划分一组相近物品的游戏代码术语，用于决定物品的生成。玩家们谈论TC时通常会涉及到武器和防具其中之一。武器和防具各自有30个TCs相对应，从3-90，每隔3升一级。</p>
<p>  　　Alvl——AffixLevel词缀等级，游戏中对每一个魔法前缀和后缀有相应的等级设定，这将决定什么样的Ilvl物品等级才能出现它们</p>
<p>  ama:<br>  Bowazon使用Bow或Crossbow类武器为主要攻击手段的Amazon；</p>
<p>  　　Jabazon使用Spears类武器，并以Jab为主要攻击手段的Amazon；</p>
<p>  　　Javazon使用投掷类(主要是Javelins标枪)武器，并以Lightningfury或PlagueJavelin为主要攻击手段的Amazon；</p>
<p>  　　BowandCrossbow——弓箭和弩箭技能树——弓和十字弓技能</p>
<p>  　　MagicArrow——魔法箭——魔法箭；简称:MA</p>
<p>  　　FireArrow——火之箭——火焰箭；简称:FA</p>
<p>  　　ColdArrow——冷之箭——冰箭；</p>
<p>  　　MultipleShot——多重打击——多重箭；简称:MS</p>
<p>  　　ExplodingArrow——爆破箭——爆裂箭；</p>
<p>  　　IceArrow——冰之箭——急凍箭；</p>
<p>  　　GuidedArrow——向导之箭——導引箭；简称:GA</p>
<p>  　　Strafe——惩罚——砲轟；俗称:扫射</p>
<p>  　　ImmolatingArrow——火墙箭——犧牲之箭；简称:Immo</p>
<p>  　　FreezingArrow——冷冻箭——凍結之箭；简称:FA</p>
<p>  　　PassiveandMagic——被动与魔法技能——被動和魔法技能</p>
<p>  　　InnerSight——心灵视觉——内視；</p>
<p>  　　CriticalShot——临界一击——致命攻擊；简称:CS</p>
<p>  　　Dodge——躲避——閃避；</p>
<p>  　　SlowMissiles——缓慢攻击——慢速箭；简称:SM</p>
<p>  　　Avoid——消除——躲避；</p>
<p>  　　Penetrate——渗透——刺入；</p>
<p>  　　Decoy——诱骗——誘餌；</p>
<p>  　　Evade——规避——迴避；</p>
<p>  　　Valkyrie——瓦尔基里——女武神；简称:Valk</p>
<p>  　　Pierce——刺穿——穿刺；</p>
<p>  　　JavelinandSpear——标枪和魔法技能树——標槍和長矛技能</p>
<p>  　　Jab——猛刺——戳刺；</p>
<p>  　　PowerStrike——能量穿透——威力一擊；</p>
<p>  　　PoisonJavelin——毒之枪——毒槍；</p>
<p>  　　Impale——穿刺——刺爆；</p>
<p>  　　LightningBolt——闪电——閃電球；</p>
<p>  　　ChargedStrike——冲刺打击——充能一擊</p>
<p>  　　PlagueJavelin——瘟疫之枪——瘟疫標槍；</p>
<p>  　　Fend——保护——擊退；</p>
<p>  　　LightningStrike——闪电打击——閃電攻擊；</p>
<p>  　　Lightningfury——狂暴闪电——閃電之怒；简称:LF</p>
<p>  　　亚马逊常用武器装备中英文名称对照：</p>
<p>  　　Buriza-DoKyanon布理撒多凱南俗称：玻璃渣/大炮；</p>
<p>  　　CruelMatriarchalBow残忍的女族長之弓。最常见的DIYBow；简称：CMBow</p>
<p>  　　DIYBow就是玩家自己cube或shopping来再镶以40ED/15IASJewel的Bow。以其无可比拟的高速Frame为部分玩家所喜好；</p>
<p>  　　Eaglehorn鷹號角简称:EH；或称EBow</p>
<p>  　　GoldstrikeArch金色的曲线；</p>
<p>  　　Lycander‘sAim雷山得的指標；</p>
<p>  　　Lycander‘sFlank雷山得的側腹；</p>
<p>  　　M‘avina‘sCaster马维娜的施展——马维娜之战斗诗歌；</p>
<p>  　　Titan‘sRevenge泰坦的復仇简称:Titan；</p>
<p>  　　Windforce風之力简称:wf；<br>  asn:<br>  Trapper以Traps陷阱系技能为主要攻击方式的Assassin；</p>
<p>  　　MAAsn以MartialArt武术系技能为主要攻击方式的Assassin；</p>
<p>  　　c/cAsn使用claw+claw双爪作战的Assassin;又称：DualclawAsn；</p>
<p>  　　c/sAsn使用claw+shield爪盾组合方式作战的Assassin；</p>
<p>  　　DualclawAsn即c/cAsn；</p>
<p>  　　MartialArt——武术技能树——武學藝朮简称:MA</p>
<p>  　　TigerStrike——虎击——虎擊；简称:TS</p>
<p>  　　DragonTalon——龙足——龍爪；</p>
<p>  　　DragonClaw——龙爪——雙龍爪；简称:DC</p>
<p>  　　FistsofFire——火拳——焰拳；简称:fof</p>
<p>  　　CobraStrike——眼镜蛇之击——眼鏡蛇攻擊；简称:CS</p>
<p>  　　DragonTail——龙尾——神龍擺尾；简称:DT</p>
<p>  　　ClawsofThunder——雷鸣爪——雷電爪；简称:cot</p>
<p>  　　BladesofIce——冰之刃——寒冰刃；简称:boi</p>
<p>  　　DragonFlight——龙翔——飛龍在天；简称:DF</p>
<p>  　　PhoenixStrike——凤舞——鳳凰攻擊；简称:PS</p>
<p>  　　ShadowDisciplines——幻影技能树——影子訓練</p>
<p>  　　ClawMastery——钢爪精通——支配利爪；简称:CM</p>
<p>  　　PsychicHammer——通灵之锤——心靈戰槌；</p>
<p>  　　BurstofSpeed——爆发速度——加速；简称:BoS</p>
<p>  　　CloakofShadows——幻影披风——魔影斗篷；简称:CoS</p>
<p>  　　WeaponBlock——武器格挡——武器格擋；简称:WB</p>
<p>  　　Fade——消退——能量消解；</p>
<p>  　　ShadowWarrior——幻影战士——影子戰士；</p>
<p>  　　MindBlast——意识攻击波——精神爆震；简称:MB</p>
<p>  　　Venom——毒液——毒牙；</p>
<p>  　　ShadowMaster——幻影精通——支配影子；简称:SM</p>
<p>  　　Traps——陷阱技能树——陷阱</p>
<p>  　　FireBlast——火焰冲击波——火焰爆震；</p>
<p>  　　ShockWeb——电击网——閃電網；</p>
<p>  　　BladeSentinel——刀刃哨兵——刃之守衛；</p>
<p>  　　ChargedBoltSentry——闪电岗哨——電能守衛；</p>
<p>  　　WakeOfFire——火之复苏——火焰復甦；简称:WoF</p>
<p>  　　BladeFury——狂暴之刃——刃之怒；</p>
<p>  　　LightningSentry——闪电陷阱——雷光守衛；简称:LS</p>
<p>  　　WakeOfInferno——地狱火之复苏——復甦獄火；</p>
<p>  　　DeathSentry——死亡陷阱——亡者守衛；简称:DS</p>
<p>  　　BladeShield——刀盾——刀刃之盾；</p>
<p>  　　刺客常用武器装备中英文名称对照：</p>
<p>  　　Bartuc‘sCut-Throat巴特克的猛擊；</p>
<p>  　　Natalya‘sMark娜塔垭的标记——娜塔亚的非难俗称：绿爪，AsnSetClaws</p>
<p>  　　还有部分Cruel前缀的Elite蓝色爪(有些是Ethereal无形的)；比如常见的CruelScissorsSuwayyah残忍的近身剪；简称:CSS</p>
<p>  　　CruelScissorsSuwayyahofQuickness残忍之快速的近身剪；简称:CSSQ</p>
<p>  bar:<br>  Ssbar以Sword+Shield剑盾组合方式作战的Barbarian，目前的主流Bar玩法，多以WW为主要攻击技能；</p>
<p>  　　Throwingbar使用投掷类(Javelins标枪较好)武器，以Doublethrow为主要攻击技能的Barbarian；</p>
<p>  　　Frenzybar使用双手武器，以Frenzy为主要攻击技能的Barbarian；</p>
<p>  　　Spearian以Spears类武器为主要攻击手段的Barbarian；</p>
<p>  　　WarCries——战斗呼声技能树——呐喊</p>
<p>  　　Howl——怒吼——狂嚎；</p>
<p>  　　Findpotion——寻找药剂——找尋藥劑；</p>
<p>  　　Taunt——辱骂——嘲弄；</p>
<p>  　　Shout——咆哮——大叫；</p>
<p>  　　Finditem——寻找物品——找尋物品；</p>
<p>  　　Battlecry——战斗口号——戰嚎；</p>
<p>  　　Battleorders——战斗号令——戰鬥體制；简称:BO</p>
<p>  　　GrimWard——严密防护——殘酷嚇阻；</p>
<p>  　　Warcry——战争呼声——戰鬥狂嚎；</p>
<p>  　　Battlecommand——战斗命令——戰鬥指揮；简称:BC</p>
<p>  　　CombatMasteries——战斗动作掌握技能树——戰鬥專家</p>
<p>  　　Swordmastery——剑术掌握——支配長劍；简称:SM</p>
<p>  　　Axemastery——战斧掌握——支配斧頭；</p>
<p>  　　Macemastery——钉头槌掌握——支配釘頭槌；</p>
<p>  　　Polearmmastery——长杆武器掌握——支配長棍；</p>
<p>  　　Throwingmastery——投掷武器掌握——支配飛擲；</p>
<p>  　　Spearmastery——枪矛掌握——支配長矛；</p>
<p>  　　Increasedstamina——增强持久力——增加耐力；</p>
<p>  　　Ironskin——钢铁皮肤——鉄布杉；简称:IS</p>
<p>  　　Increasedspeed——增强移动力——加速；</p>
<p>  　　Naturalresistance——自然抗力——自然抵抗；简称:NR</p>
<p>  　　Combat——战斗技能树——戰鬥技能</p>
<p>  　　Bash——怒殴——重擊；</p>
<p>  　　Leap——飞跃——跳躍；</p>
<p>  　　Doubleswing——双重挥舞——雙手揮擊；</p>
<p>  　　Stun——晕眩——擊昏；</p>
<p>  　　Doublethrow——双重投掷——雙手投擲；简称:DT</p>
<p>  　　Leapattack——跳跃攻击——跳躍攻擊；简称:LA</p>
<p>  　　Concentrate——集中——專心；</p>
<p>  　　Frenzy——狂怒——狂亂；</p>
<p>  　　Whirlwind——旋风——旋風；简称:WW</p>
<p>  　　Berserk——狂暴——狂戰士；</p>
<p>  　　野蛮人常用武器装备中英文名称对照：</p>
<p>  　　BulKathosSacredCharge布爾凱索的神聖代價——布爾凱索的孩子俗称：Set大剑；</p>
<p>  　　BulKathosTribalGuardian布爾凱索的部族守护——布爾凱索的孩子俗称：Set小剑；</p>
<p>  　　CruelColossusBlade残忍的巨神之刃简称：CCB；</p>
<p>  　　CruelColossussword残忍的巨神之剑简称：CCS；</p>
<p>  　　CruelColossusBladeofQuickness残忍之快速的巨神之刃简称：就是著名的CCBQ了；</p>
<p>  　　CruelColossusBladeofSwiftness残忍之敏捷的巨神之刃简称：CCBS；</p>
<p>  　　CruelBeserkerAxeofQuickness残忍之快速的狂戰士斧简称：CBAQ;</p>
<p>  　　CruelHyperionJavelin残忍之亥伯龍之槍(throwingbar推荐选用)</p>
<p>  　　CruelWingedHarpoon残忍之翼魚叉(throwingbar推荐选用)</p>
<p>  　　Doombringer末日毀滅者；简称:Doom</p>
<p>  　　TheGrandfather祖父;简称：GF(女朋友？@_@:$)；</p>
<p>  　　Lightsabre光之軍刀；简称:LS</p>
<p>  　　fury神符之语剑狂暴，常用BalrogBlade制作；<br>   dru:<br>  ElementalistDruid以Elemental元素系技能为主要攻击方式的Druid；</p>
<p>  　　Grizzlygeddon使用Armageddon+SummonGrizzly为主要攻击技能的Druid；</p>
<p>  　　WWdruid即werewolfdruid，就是变狼的Druid；</p>
<p>  　　Elemental——自然力技能树——元素</p>
<p>  　　Firestorm——暴火——火風爆；</p>
<p>  　　MoltenBoulder——熔石——熔漿巨岩；</p>
<p>  　　ArcticBlast——北极冰风——極地風暴；简称:AB</p>
<p>  　　Fissure——裂缝——火山爆；</p>
<p>  　　CycloneArmor——暴风盔甲——颶風裝甲；简称:CA</p>
<p>  　　Twister——缠绕——縑鼬風；</p>
<p>  　　Volcano——火山——火山；</p>
<p>  　　Tornado——龙卷风——龍捲風；</p>
<p>  　　Hurricane——飓风——暴風；</p>
<p>  　　Armageddon——末日战唱—毀天滅地；</p>
<p>  　　ShapeShifting——形态转变技能树——外型變形</p>
<p>  　　Werewolf——人狼——狼人變化；</p>
<p>  　　Lycanthropy——变狼狂——變形朮；</p>
<p>  　　Werebear——人熊——熊人變化；</p>
<p>  　　Maul——大槌——撞槌；</p>
<p>  　　FeralRage——野兽的愤怒——野性狂暴；</p>
<p>  　　FireClaws——火爪——焰爪；</p>
<p>  　　Rabies——狂犬——狂犬病；</p>
<p>  　　ShockWave——冲击波——震波；</p>
<p>  　　Hunger——饥饿——飢餓；</p>
<p>  　　Fury——狂怒——狂怒；</p>
<p>  　　Summoning——召唤技能树——召喚</p>
<p>  　　Raven——乌鸦——烏鴉；</p>
<p>  　　PoisonCreeper——毒藤——猛毒花藤；</p>
<p>  　　OakSage——橡树贤者——橡木智者；简称:OS</p>
<p>  　　SummonSpiritWolf——召唤精灵狼——召喚鬼狼；</p>
<p>  　　CarrionVine——死腐藤——食尸藤；</p>
<p>  　　HeartofWolverine——狼之心——狼獾之心；简称:HoW</p>
<p>  　　SummonDireWolf——召唤恶狼——召喚狂狼；</p>
<p>  　　SolarCreeper——太阳藤蔓)(太陽藤；</p>
<p>  　　SpiritofBarbs——精神倒刺——棘靈；</p>
<p>  　　SummonGrizzly——召唤灰熊——召喚灰熊；简称:Griz</p>
<p>  　　德鲁依常用武器装备中英文名称对照：</p>
<p>  　　Baranar‘sStar巴拉那之星；有时可简称为DS;</p>
<p>  　　Buriza-DoKyanon布理撒多凱南俗称：玻璃渣/大炮；</p>
<p>  　　CruelColossusBladeofQuickness残忍之快速的巨神之刃;简称：就是著名的CCBQ了；</p>
<p>  　　CruelBeserkerAxeofQuickness残忍之快速的狂戰士斧简称：CBAQ</p>
<p>  　　Hellslayer地獄毀滅者；</p>
<p>  　　ImmortalKing‘sStoneCrusher不朽之王的石头压碎者；简称:IKMaul；</p>
<p>  　　Messerschmidt‘sReaver希梅斯特的掠奪；</p>
<p>  　　Schaefer‘sHammer史恰佛之鎚；</p>
<p>  　　TheCraniumBasher碎腦槌；</p>
<p>  nec:</p>
<p>  　　Zookeeper以Summoning为主要技能，辅以各种Curses的Necromancer；</p>
<p>  　　Meleemancer以近身格斗为主要攻击手段，而不依赖召唤大批奴仆的肉搏型Necromancer；</p>
<p>  　　Poisonmancer以毒系技能为主要攻击方式，有些以骨系技能辅助的Necromancer；</p>
<p>  　　Venomancer用PoisonDagger攻击的Necromancer</p>
<p>  　　Summoning——召唤系技能树——召喚法術</p>
<p>  　　Skeletonmastery——骷髅掌握——支配骷髏；</p>
<p>  　　Raiseskeleton——复活骷髅——骷髏復甦；</p>
<p>  　　ClayGolem——土之巨人——黏土石魔；简称:CG</p>
<p>  　　GolemMastery——傀儡掌握——支配石魔；简称:GM</p>
<p>  　　Raiseskeletalmage——复活骷髅魔法师——復甦骷髏法師；</p>
<p>  　　BloodGolem——血之巨人——鮮血石魔；简称:BG</p>
<p>  　　Summonedresistance——召唤反抗——召喚抵抗；</p>
<p>  　　IronGolem——钢铁巨人——鋼鐵石魔；简称:IG</p>
<p>  　　FireGolem——火之巨人——火焰石魔；简称:FG</p>
<p>  　　Revive——复兴——重生；</p>
<p>  　　Poisonandbone——毒系骨系技能树——毒素和白骨法術</p>
<p>  　　Teech——牙齿术——牙；</p>
<p>  　　BoneArmor——骨之护甲——白骨裝甲；简称:BA</p>
<p>  　　PoisonDagger——毒之匕首——淬毒匕首；简称:PD(骗点？)</p>
<p>  　　CorpseExplosion+——尸体爆炸术——屍體爆炸；简称:CE</p>
<p>  　　BoneWall——骨墙术——骨墻；</p>
<p>  　　PoisonExplosion——毒气爆炸术——毒爆；</p>
<p>  　　BoneSpear——骨之长矛——骨矛；</p>
<p>  　　BonePrison——骸骨监狱——骨牢；</p>
<p>  　　PoisonNova——毒之雷星——劇毒新星；简称:PN</p>
<p>  　　Bonespirit——骨之灵魂——白骨之魂；简称:BS</p>
<p>  　　Curses——诅咒系技能树——詛咒</p>
<p>  　　AmplifyDamage——加大伤害——傷害加深；简称:Amp/Ad</p>
<p>  　　DimVision——视力模糊——微暗靈視；简称:Dim</p>
<p>  　　Weaken——弱化——削弱；</p>
<p>  　　Ironmaiden——钢铁处女——攻擊反噬；简称:IM</p>
<p>  　　Terror——恐怖——恐懼；</p>
<p>  　　Confuse——混乱——迷亂；</p>
<p>  　　LifeTap——生命源泉——偷取生命；</p>
<p>  　　Attracc——吸引——吸引；</p>
<p>  　　Decrepify——衰老——衰老；简称:Decrep/Dec</p>
<p>  　　LowerResist——降低抵抗力——降低抵抗；简称:LR(烂人@_@)</p>
<p>  　　巫师常用武器装备中英文名称对照：</p>
<p>  　　SuicideBranch自殺支系；</p>
<p>  　　BlackhandKey黑手之鑰；</p>
<p>  　　Wizardspike巫師之刺；</p>
<p>  pal:<br>  Avenger以Vengeance+Conviction为主要攻击技能的Paladin；</p>
<p>  　　Charger/Chargedin以Charge为主要攻击技能的Paladin；</p>
<p>  　　Hammerdin以Concentration+Blessedhammer为主要攻击技能的Paladin；简称:BHdin</p>
<p>  　　Zealot使用Zeal为为主要攻击技能的Paladin；</p>
<p>  　　DefensiveAuras——防御技能树——防禦性靈氣</p>
<p>  　　Prayer——祈祷——祈禱；</p>
<p>  　　ResistFire——火之光环——抗火；</p>
<p>  　　Defiance——藐视光环——反抗；</p>
<p>  　　ResistCold——冰之光环——抗冰冷；</p>
<p>  　　Cleansing——洁净光环——淨化；</p>
<p>  　　ResistLightning——闪电光环——抵抗閃電；</p>
<p>  　　Vigor——活力光环——精力；</p>
<p>  　　Meditation——冥想光环——冥想；</p>
<p>  　　Redemption——补偿光环——救贖；</p>
<p>  　　Salvation——拯救光环——救助；</p>
<p>  　　OffensiveAuras——攻击技能树——攻擊靈氣</p>
<p>  　　Might——力量光环——力量；</p>
<p>  　　Holy-Fire——神圣之火——聖火；</p>
<p>  　　Thorns——荆棘光环——刺針；</p>
<p>  　　BlessedAim——祝福光环——祝福瞄準；</p>
<p>  　　Concentration——集中——專注；简称:Conc</p>
<p>  　　HolyFreeze——圣洁寒冰——神聖冰凍；简称:HF</p>
<p>  　　HolyShock——神圣打击——聖光衝擊；</p>
<p>  　　Sanctuary——避难所——庇護所；</p>
<p>  　　Fanaticism——狂热——狂熱；简称:Fana</p>
<p>  　　Conviction——审判——信念；简称:Conv</p>
<p>  　　Combat——战斗技能树——作戰技能</p>
<p>  　　Sacrifice——牺牲——犧牲；</p>
<p>  　　Smite——重击——重擊；</p>
<p>  　　Holybolt——圣光术——聖光彈；</p>
<p>  　　Zeal——热诚——白熱；</p>
<p>  　　Charge——冲锋——突擊</p>
<p>  　　Vengeance——复仇——復仇；简称:Veng</p>
<p>  　　Blessedhammer——神圣之槌——祝福之錘；简称:BH</p>
<p>  　　Conversion——转化——轉換；</p>
<p>  　　Holyshield——神圣之盾——神聖之盾；简称:HS</p>
<p>  　　Fistoftheheavens——天神之手——天堂之拳；简称:FoH</p>
<p>  　　圣骑士常用武器装备中英文名称对照：</p>
<p>  　　Baranar‘sStar巴拉那之星；有时可简称为DS;</p>
<p>  　　Griswold‘sRedemption格瑞斯华尔德的救赎——格瑞斯华尔德的的传奇；</p>
<p>  　　Lightsabre光之軍刀；简称:LS</p>
<p>  　　Sazabi‘sCobaltRedeemer沙撒壁的忏悔之钴——沙撒壁的雄伟贡品；</p>
<p>  　　Schaefer‘sHammer史恰佛之鎚；简称:Mallet</p>
<p>  　　CruelBeserkerAxeofQuickness残忍之快速的狂戰士斧简称：CBAQ</p>
<p>  　　还有部分Cruel前缀或做成fury的Elite武器比如：PhaseBlade，ConquestSword，CrypticSword,MythicalSword，BerserkerAxe,其中PhaseBlade不能通过Cube合成获得Cruel的前缀；</p>
<p>   sor:<br>  Boltress以ChargedBolt为主要攻击技能的Sorceress；</p>
<p>  　　Tweaker指一部分将FCR(FasterCastRate快速施法率)增强到max的Sorceress；</p>
<p>  　　Cold——冰系技能树——冰凍法術</p>
<p>  　　Icebolt——冰箭——冰彈；</p>
<p>  　　FrozenArmor——寒冰护甲——冰封裝甲；</p>
<p>  　　FrostNova——霜之星——霜之新星；简称:FN</p>
<p>  　　IceBlast——寒冰冲击波——冰風暴；</p>
<p>  　　ShiverArmor——战栗护盾——碎冰甲；</p>
<p>  　　GlacialSpike——冰之长钉——冰尖柱；简称:GS</p>
<p>  　　Blizzard——暴风雪——暴風雪；</p>
<p>  　　ChillingArmor——寒冷装甲——寒冰裝甲；</p>
<p>  　　FrozenOrb——冰冻球——冰封球；简称:FO</p>
<p>  　　ColdMatery——寒冰掌握——支配冰冷；简称:CM</p>
<p>  　　Lighting——闪电系技能树——閃電法術</p>
<p>  　　ChargedBolt——闪电弹——充能彈；简称:CB</p>
<p>  　　StaticField——静力唱—靜態力場；简称:SF</p>
<p>  　　Telekinesis——心灵念力术——心靈傳動；简称:TK</p>
<p>  　　Nova——雷星术——新星；</p>
<p>  　　Lightning——闪电——閃電；</p>
<p>  　　ChainLightning——连环闪电——連鎖閃電；简称:CL</p>
<p>  　　Teleport——心灵传送术——傳送；简称:Tele/TP</p>
<p>  　　ThunderStorm——雷暴术——雷云風暴；简称:TS</p>
<p>  　　EnergyShield——能量盾——能量護盾；简称:ES</p>
<p>  　　LightningMastery——闪电掌握——支配閃電；简称:LM</p>
<p>  　　Fire——火系技能树——火焰法術</p>
<p>  　　Firebolt——小火球——火彈；简称:fb</p>
<p>  　　Warmth——热情——暖氣；简称:</p>
<p>  　　Inferno——地狱火——地獄之火；</p>
<p>  　　Blaze——火焰道标——熾烈之焰；</p>
<p>  　　Fireball——大火球——火球；简称:FB</p>
<p>  　　Firewall——火墙术——火墻；简称:FW</p>
<p>  　　Enchant——施魔——強化；</p>
<p>  　　Meteor——流星——隕石；</p>
<p>  　　Hydra——守护神——九頭海蛇；</p>
<p>  　　FireMastery——火系掌握——支配之焰；简称:FM</p>
<p>  　　女巫常用武器装备中英文名称对照：</p>
<p>  　　BladeOfAliBaba阿里巴巴之刃；简称:AliBaba</p>
<p>  　　Gull海鷗;</p>
<p>  　　KelpieSnare水魔陷阱，这个当然不是给女巫MM用的啦，是给我们的”小强”用的；</p>
<p>  　　TheOculus眼球简称:Orb；</p>
<p>  　　Wizardspike巫師之刺；</p>
<p>  　　有时一些属性JP的RareOrb也常常会被部分pvp女巫使用；</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.igiven.com/dotnet-2020-02-03-orleans-Deployment/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhepama">
      <meta itemprop="description" content="一个不专业的程序员,写着不专业的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IGiven">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/dotnet-2020-02-03-orleans-Deployment/" class="post-title-link" itemprop="url">orleans的部署模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-03 08:00:00" itemprop="dateCreated datePublished" datetime="2020-02-03T08:00:00+08:00">2020-02-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-16 12:44:43" itemprop="dateModified" datetime="2020-07-16T12:44:43+08:00">2020-07-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/dotnet/" itemprop="url" rel="index"><span itemprop="name">dotnet</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="蓝绿部署（Blue-Green-Deployment）"><a href="#蓝绿部署（Blue-Green-Deployment）" class="headerlink" title="蓝绿部署（Blue/Green Deployment）"></a>蓝绿部署（Blue/Green Deployment）</h1><p>过去的 10 年里，很多公司都在使用蓝绿部署（发布）来实现热部署，这种部署方式具有安全、可靠的特点。蓝绿部署虽然算不上“ Sliver Bullet”，但确实很实用。<br>蓝绿部署是最常见的一种0 downtime部署的方式，是一种以可预测的方式发布应用的技术，目的是减少发布过程中服务停止的时间。蓝绿部署原理上很简单，就是通过冗余来解决问题。通常生产环境需要两组配置（蓝绿配置），一组是active的生产环境的配置（绿配置），一组是inactive的配置（蓝绿配置）。用户访问的时候，只会让用户访问active的服务器集群。在绿色环境（active）运行当前生产环境中的应用，也就是旧版本应用version1。当你想要升级到version2 ，在蓝色环境（inactive）中进行操作，即部署新版本应用，并进行测试。如果测试没问题，就可以把负载均衡器／反向代理／路由指向蓝色环境了。随后需要监测新版本应用，也就是version2 是否有故障和异常。如果运行良好，就可以删除version1 使用的资源。如果运行出现了问题，可以通过负载均衡器指向快速回滚到绿色环境。<br>蓝绿部署的优点：<br>这种方式的好处在你可以始终很放心的去部署inactive环境，如果出错并不影响生产环境的服务，如果切换后出现问题，也可以在非常短的时间内把再做一次切换，就完成了回滚。而且同时在线的只有一个版本。蓝绿部署无需停机，并且风险较小。<br>(1) 部署版本1的应用（一开始的状态），所有外部请求的流量都打到这个版本上。<br>(2) 部署版本2的应用，版本2的代码与版本1不同(新功能、Bug修复等)。<br>(3) 将流量从版本1切换到版本2。<br>(4) 如版本2测试正常，就删除版本1正在使用的资源（例如实例），从此正式用版本2。<br>从过程不难发现，在部署的过程中，应用始终在线。并且，新版本上线的过程中，并没有修改老版本的任何内容，在部署期间，老版本的状态不受影响。这样风险很小，并且，只要老版本的资源不被删除，理论上，可以在任何时间回滚到老版本。<br>蓝绿部署的弱点：<br>使用蓝绿部署需要注意的一些细节包括：<br>1、当切换到蓝色环境时，需要妥当处理未完成的业务和新的业务。如果数据库后端无法处理，会是一个比较麻烦的问题。<br>2、有可能会出现需要同时处理“微服务架构应用”和“传统架构应用”的情况，如果在蓝绿部署中协调不好这两者，还是有可能导致服务停止；<br>3、需要提前考虑数据库与应用部署同步迁移/回滚的问题。<br>4、蓝绿部署需要有基础设施支持。<br>5、在非隔离基础架构（ VM 、 Docker 等）上执行蓝绿部署，蓝色环境和绿色环境有被摧毁的风险。<br>6、另外，这种方式不好的地方还在于冗余产生的额外维护、配置的成本，以及服务器本身运行的开销。<br>蓝绿部署适用的场景：<br>1、不停止老版本，额外搞一套新版本，等测试发现新版本OK后，删除老版本。<br>2、蓝绿发布是一种用于升级与更新的发布策略，部署的最小维度是容器，而发布的最小维度是应用。<br>3、蓝绿发布对于增量升级有比较好的支持，但是对于涉及数据表结构变更等等不可逆转的升级，并不完全合适用蓝绿发布来实现，需要结合一些业务的逻辑以及数据迁移与回滚的策略才可以完全满足需求。</p>
<h1 id="滚动发布（rolling-update）"><a href="#滚动发布（rolling-update）" class="headerlink" title="滚动发布（rolling update）"></a>滚动发布（rolling update）</h1><p>滚动发布，一般是取出一个或者多个服务器停止服务，执行更新，并重新将其投入使用。周而复始，直到集群中所有的实例都更新成新版本。这种部署方式相对于蓝绿部署，更加节约资源——它不需要运行两个集群、两倍的实例数。我们可以部分部署，例如每次只取出集群的20%进行升级。<br>这种方式也有很多缺点，例如：<br>(1) 没有一个确定OK的环境。使用蓝绿部署，我们能够清晰地知道老版本是OK的，而使用滚动发布，我们无法确定。<br>(2) 修改了现有的环境。<br>(3) 如果需要回滚，很困难。举个例子，在某一次发布中，我们需要更新100个实例，每次更新10个实例，每次部署需要5分钟。当滚动发布到第80个实例时，发现了问题，需要回滚。此时，脾气不好的程序猿很可能想掀桌子，因为回滚是一个痛苦，并且漫长的过程。<br>(4) 有的时候，我们还可能对系统进行动态伸缩，如果部署期间，系统自动扩容/缩容了，我们还需判断到底哪个节点使用的是哪个代码。尽管有一些自动化的运维工具，但是依然令人心惊胆战。<br>并不是说滚动发布不好，滚动发布也有它非常合适的场景。</p>
<p><img src="../../assets/images/2020-02-03-orleans-Deployment/20190516171224267.png" alt="img"></p>
<h1 id="orleans支持-蓝绿部署模型以及滚动部署模型"><a href="#orleans支持-蓝绿部署模型以及滚动部署模型" class="headerlink" title="orleans支持 蓝绿部署模型以及滚动部署模型"></a>orleans支持 <em>蓝绿部署模型<em>以及</em>滚动部署模型</em></h1><ul>
<li><p>ClusterId：这是Orleans集群的唯一ID。使用此ID的所有客户端和Silo将能够直接相互通信。但是，您可以选择ClusterId对不同的部署使用不同的名称。</p>
</li>
<li><p>ServiceId：这是您的应用程序的唯一ID，将由某些提供程序（例如持久性提供程序）使用。此ID应该保持稳定，并且在整个部署中都不应更改。</p>
</li>
</ul>
<p>Orleans has both <code>ClusterId</code> &amp; <code>ServiceId</code> to support the <em>blue/green deployment model</em>.</p>
<p>In this model, each deployment slot will have a distinct <code>ClusterId</code> (eg, the values could be “blue-slot” &amp; “green-slot”) but they will always have the same <code>ServiceId</code> (eg, “my-service”). The “blue-slot” silos will only talk to other “blue-slot” silos.</p>
<p><em>However</em> <strong>Grain A</strong> in the blue cluster and <strong>Grain A</strong> in the green cluster will still share the same storage - if they are both active then one will see a conflict when writing to the state if the other activation has already written it.</p>
<p>This allows for the state in the database to remain consistent when multiple clusters are active (which is usually a short period of time - during the upgrade).</p>
<p>If you do not use blue/green deployments then you can set <code>ClusterId</code> &amp; <code>ServiceId</code> to the same value.</p>
<p>To say this in a different way:</p>
<ul>
<li><code>ClusterId</code> + <code>ServiceId</code> are used for cluster membership</li>
<li><code>ServiceId</code> is used for storage</li>
</ul>
<p><a href="https://github.com/dotnet/orleans/issues/5696#issuecomment-503595998" target="_blank" rel="noopener">https://github.com/dotnet/orleans/issues/5696#issuecomment-503595998</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.igiven.com/dotnet-2020-02-02-Latency-Compensating-rtt/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhepama">
      <meta itemprop="description" content="一个不专业的程序员,写着不专业的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IGiven">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/dotnet-2020-02-02-Latency-Compensating-rtt/" class="post-title-link" itemprop="url">延迟补偿和对时的相关总结</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-02 08:00:00" itemprop="dateCreated datePublished" datetime="2020-02-02T08:00:00+08:00">2020-02-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-16 12:44:43" itemprop="dateModified" datetime="2020-07-16T12:44:43+08:00">2020-07-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/dotnet/" itemprop="url" rel="index"><span itemprop="name">dotnet</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>国内的网络游戏多是客户端/服务器方式，而对于游戏实时性要求比较高的网游，如 果采用客户端发送时间包给服务器，服务器校验后再下发给客户端表现的话，网络延时 和抖动都会恶化游戏体验。对于客户端和服务器的同步问题， 一般有两种算法解决：</p>
<p>① 、客户端和服务器之间进行对时后，客户端发送数据包给服务器，服务器根据收 到的客户端数据包先后进行排序，先到达的服务器端的事件包被判定为先发生，后到达 服务器的事件包被判定为后发生。在此情况下，往往网络延时较大的客户端先发送了游 戏事件包，但由于网络延时和抖动的影响，后到达服务器，而被判定为后发生时间，这 样对该客户端就不公平了。</p>
<p>② 、客户端和服务器进行对时后，客户端预测服务器收到客户端数据包的时间，并 把该时间写入数据包中发送给服务器，在网络抖动比较大的情况下，这种情况可以保证一定的公平性。但是还是出现了上述的情况，网络延时大的数据包预测的到达时间也就 更晚，依然会出现先发生的事件被服务器判定为后发生，同样不能保证游戏的公平性。</p>
<p>因此，在现有的解决网络实时性较差问题的技术方案中，当采用TimeWarp同步机制 时，则需要保存数量较多的快照，同时也会使回滚的次数较多，导致过多的消耗内存和 CPU资源，以及降低游戏体验；对于国内网络游戏采用的网络时间同步机制，无论服务器 根据客户端数据包到达的时间进行排序，或客户端预测服务器收到客户端数据包的时间 并把该时间写入数据包中发送给服务器，对于网络延时越大的玩家同样会降低游戏体 验。</p>
<h2 id="网络对时"><a href="#网络对时" class="headerlink" title="网络对时"></a>网络对时</h2><p>大部分的强交互网游会做对时, 使 client 和 server 保持时间基本一致.</p>
<p><img src="../../assets/images/2020-02-02-Latency_Compensating-rtt/iyeruicpsm.png" alt="img"></p>
<ol>
<li>client 带上本地时间 t0 向 server 发送对时请求.</li>
<li>server 回复当前自己的系统时间 t1.</li>
<li>client ack 收到 server 回复时的本地时间 t2.</li>
</ol>
<p>如果只有 client 关心对时结果, 这时可以优化到<strong>只做1,2步甚至只做第2步</strong>, 相当于 client 主动发起 ping;</p>
<p>同样, 如果只有 server 关心对时结果, sever 主动发起 ping (第2,3步)即可.</p>
<p>单次对时往往会受到网络波动的影响, 所以一般还需要做多次统计一个比较合理的时间偏移.</p>
<p>网络对时, 一般在进游戏之初做. 如果在游戏过程中发现有网络波动过大的情况(在下行协议包中带上 server 的时间, 很容易检查到提前或者滞后), 也需要重新发起对时.</p>
<p>考虑到反外挂(比如加速齿轮, 或者减速器)的因素, server 端需要对主动发起的client对时请求做一些安全校验, 例如时间递增, 是否满足阈值等等.</p>
<p>光从对时的角度来看, UDP 协议比 TCP 更合适一些, 不过取决于项目需要.</p>
<h2 id="服务器和客户端时间差算法-st0-st2-2ct1-2"><a href="#服务器和客户端时间差算法-st0-st2-2ct1-2" class="headerlink" title="服务器和客户端时间差算法 (st0+st2-2ct1)/2"></a>服务器和客户端时间差算法 <strong>(st0+st2-2ct1)/2</strong></h2><p> <img src="../../assets/images/2020-02-02-Latency_Compensating-rtt/image-20200221152318844.png" alt="image-20200221152318844"></p>
<h3 id="两种理解方式"><a href="#两种理解方式" class="headerlink" title="两种理解方式"></a>两种理解方式</h3><h4 id="第一种方式"><a href="#第一种方式" class="headerlink" title="第一种方式"></a>第一种方式</h4><p><code>ct1-st0 = &amp;0 +(ct1-st1)</code>  延迟+ 时间差(同一时刻下客户端减去服务端的时间差)</p>
<p><code>st2-ct1 = &amp;1+(st2-ct2)</code>  延迟+ 时间差(同一时刻下服务端减去客户端的时间差)</p>
<p>我们需要的就是<code>st2-ct2</code> 由上可以转换为<code>-(ct1-st1) = st2-ct2</code>  </p>
<p>现假设 <code>o = st2-ct2</code>同时假设延迟相等 <code>p = &amp;0 = &amp;1</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ct1-st0 &#x3D; p - o</span><br><span class="line"></span><br><span class="line">st2-ct1 &#x3D; p + o</span><br><span class="line"></span><br><span class="line">ct1-st0-st2+ct1 &#x3D; -2o</span><br><span class="line"></span><br><span class="line">o &#x3D;(st0+st2-2ct1)&#x2F;2</span><br></pre></td></tr></table></figure>

<h4 id="第二种方式"><a href="#第二种方式" class="headerlink" title="第二种方式"></a>第二种方式</h4><p><code>&amp;0 = &amp;1 = (st2-st0)/2</code>    我们知道<code>(st2-st0)/2</code>是单次延迟 即</p>
<p><code>st2-ct1 = &amp;1+(st2-ct2)</code>  延迟+ 时间差(同一时刻下服务端减去客户端的时间差)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">st2-ct1 &#x3D; (st2-st0)&#x2F;2 + o</span><br><span class="line"></span><br><span class="line">2st2-2ct1 &#x3D; st2-st0 + 2o</span><br><span class="line"></span><br><span class="line">o &#x3D; (st0+st2-2ct1)&#x2F;2</span><br></pre></td></tr></table></figure>


<p><a href="https://patents.google.com/patent/CN101577715A/zh" target="_blank" rel="noopener">https://patents.google.com/patent/CN101577715A/zh</a></p>
<p>服务器获得服务器与客户端的时间差值后，与服务器接收到来自客户端的数据包的时间做差值可以获得客户端在游 戏过程中实际向服务器发送数据包的时间，<strong>并通过客户端在游戏过程 中实际向服务器发送数据包的时间来判定在游戏时间中事件发生的实际顺序</strong>， 从而较好的保持了游戏的公平性，提高了游戏玩家的游戏体验。</p>
<h4 id="检查安全性"><a href="#检查安全性" class="headerlink" title="检查安全性"></a>检查安全性</h4><ol>
<li><p>第一次连接的对时..时差不该查过三分钟.</p>
</li>
<li><p>校验包客户端有没有修改时间,能够求得发包的时间,对比服务器接收到包的时间以及延迟</p>
</li>
</ol>
<h2 id="移动的延迟补偿"><a href="#移动的延迟补偿" class="headerlink" title="移动的延迟补偿."></a>移动的延迟补偿.</h2><p>使用了客户端预测的话,客户端的移动位置要优先于服务端的,因为有来回两次延迟..</p>
<p>由于状态同步以服务端为准,使用服务器校对不会出什么问题.</p>
<p>所以这里的补偿是补偿从客户端到服务端这段延迟.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class move</span><br><span class="line">&#123;</span><br><span class="line">	DatetimeOffset clientTime</span><br><span class="line">&#125;</span><br><span class="line">var o &#x3D; xxx;&#x2F;&#x2F;服务端和客户端的时间差</span><br><span class="line">var startMoveTime &#x3D;   move.clientTime+o;</span><br><span class="line">var delay &#x3D; DateTimeOffset.Now()-startMoveTime;&#x2F;&#x2F;延迟时间</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;todo:将延迟时间参与到pos的计算当中</span><br></pre></td></tr></table></figure>

<p>如果使用了服务器校对不补偿也并没有什么太大的问题,因为最终仍然是以服务器为准的.</p>
<p>但是补偿了之后减少了延迟,会更平缓一点.</p>
<p><a href="https://patents.google.com/patent/CN102404279A/zh" target="_blank" rel="noopener">https://patents.google.com/patent/CN102404279A/zh</a></p>
<h2 id="boss攻击的延迟补偿"><a href="#boss攻击的延迟补偿" class="headerlink" title="boss攻击的延迟补偿."></a>boss攻击的延迟补偿.</h2><p><img src="../../assets/images/2020-02-02-Latency_Compensating-rtt/image-20200221164609309.png" alt="image-20200221164609309"></p>
<p>玩家ct2的时候开始移动,但是服务器收到的时候已经是st4</p>
<p>而服务器st2的时候boss发动了攻击.这个时候.玩家在服务器的位置是在ct3</p>
<p>需要boss把攻击作为关键事件…直到客户端有ct4事件出来时再执行st2,</p>
<p>可以使用时间轮算法触发关键事件</p>
<h2 id="玩家-的延迟补偿"><a href="#玩家-的延迟补偿" class="headerlink" title="玩家 的延迟补偿"></a>玩家 的延迟补偿</h2><p>这是由于客户端使用了插值算法造成的</p>
<p>比如fps游戏,玩家看到的敌人的位置永远是过去的,当你开枪的时候,那个人其实已不在那个位置</p>
<p>所以需要记录游戏的世界状态..找到子弹打出时那一刻的世界状态.然后判定</p>
<p><a href="https://patents.google.com/patent/CN102739608A/zh" target="_blank" rel="noopener">https://patents.google.com/patent/CN102739608A/zh</a></p>
<h2 id="一些模拟恶劣网络环境工具"><a href="#一些模拟恶劣网络环境工具" class="headerlink" title="一些模拟恶劣网络环境工具"></a>一些模拟恶劣网络环境工具</h2><ul>
<li><a href="http://jagt.github.io/clumsy/cn/index.html" target="_blank" rel="noopener">http://jagt.github.io/clumsy/cn/index.html</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.igiven.com/dotnet-2020-02-02-Latency-Compensating-Methods-in-ClientServer-In-game-Protocol-Design-and-Optimization/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhepama">
      <meta itemprop="description" content="一个不专业的程序员,写着不专业的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IGiven">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/dotnet-2020-02-02-Latency-Compensating-Methods-in-ClientServer-In-game-Protocol-Design-and-Optimization/" class="post-title-link" itemprop="url">延迟补偿在C/S架构游戏协议设计和优化中的应用</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-02 08:00:00" itemprop="dateCreated datePublished" datetime="2020-02-02T08:00:00+08:00">2020-02-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-16 12:44:43" itemprop="dateModified" datetime="2020-07-16T12:44:43+08:00">2020-07-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/dotnet/" itemprop="url" rel="index"><span itemprop="name">dotnet</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-综述"><a href="#1-综述" class="headerlink" title="1.综述"></a>1.综述</h1><p>第一人称角色网络游戏的设计是一项很有挑战性的工作。网络环境下的健壮性，是动作游戏能否成功的一个重要因素。另外，PC上面的开发者需要考虑到玩家层次不齐的机器配置以及网络状况，很多用户的硬件配置跟网络跟当前最好的配置跟网络有一定差距。</p>
<p>宽带网络的出现有利于在线游戏开发，但是开发者还是需要考虑网络延迟和其它网络特性。而且宽带网络在美国被广泛采用还需要一段时间，在世界上其它国家可能需要更长的一段时间。另外，很多宽带网络质量很差，用户虽然偶尔能够享受到高带宽，但更多的时候他们不得不面对高延迟和高丢包率。</p>
<p>我们应该提供给玩家良好的游戏。本篇文章讨论了如何提供给玩家顶尖的操作体验；介绍了很多在线动作游戏中采用的C/S架构背景。此外，我们还讨论了如何通过一个预测模型来掩饰延迟带来的影响。文章的最后描述了一个叫做延迟补偿的机制，弥补了因为网络质量不好带来的负面影响</p>
<h1 id="2-C-S游戏的基本架构"><a href="#2-C-S游戏的基本架构" class="headerlink" title="2.C/S游戏的基本架构"></a>2.C/S游戏的基本架构</h1><p>网络上可玩的大部分动作游戏都是C/S结构游戏基础上修改完成的，比如半条命以及其修改版反恐精英、军团要塞，以及一些基于quake3引擎和虚幻引擎的游戏。这类游戏都有一个用来执行游戏逻辑的服务器以及连接到这个服务器的多个客户端。客户端仅仅是用来接收玩家的操作并发给服务器，服务器对这些操作作出响应，移动玩家周围物体，并将游戏世界的信息发给客户端显示出来。当然世界的游戏系统有更多组件，我们这样简化有利于分析预测和延迟补偿。</p>
<p>基于这种考虑，典型的C/S游戏引擎通常看起来是这样的</p>
<p><img src="../../assets/images/2020-02-02-Latency_Compensating_Methods_in_ClientServer_In-game_Protocol_Design_and_Optimization/Lagcomp1.png" alt="General Client / Server Architecture"></p>
<p>为了便于讨论，我们假定客户端跟服务器之间已经建立连接；客户端的每一帧循环如下：</p>
<ol>
<li><p>获取帧开始时间</p>
</li>
<li><p>采集用户输入</p>
</li>
<li><p>根据模拟时间将移动命令打包发送给服务器</p>
</li>
<li><p>获取处理服务器传过来的数据包</p>
</li>
<li><p>根据服务器数据包的内容决定可见物体及其状态</p>
</li>
<li><p>渲染场景</p>
</li>
<li><p>获取帧结束时间</p>
</li>
<li><p>结束时间减去开始时间就是下一帧的模拟时间</p>
</li>
</ol>
<p>客户端每完成一个帧循环，就用“frametime”来决定下一帧需要多少时间，如果帧率恒定，“frametime”就是准确的，否则就没办法获得准确的“frametime”（因为在没一帧开始你不可能知道这一帧需要多长时间）</p>
<p>服务器的循环大同小异：</p>
<ol>
<li><p>获取帧开始时间</p>
</li>
<li><p>读取客户端发过来的操作信息</p>
</li>
<li><p>根据客户端操作执行逻辑运算</p>
</li>
<li><p>采用上一个循环得到的模拟时间来模拟服务器控制的物体移动状态</p>
</li>
<li><p>对每一个连接的客户端，发送打包相应的物体/世界状态</p>
</li>
<li><p>获取帧结束时间</p>
</li>
<li><p>结束时间减去开始时间就是下一帧的模拟时间</p>
</li>
</ol>
<p>在这个模型中，非玩家物体完全由服务器控制其状态，每个玩家根据服务器发过来的数据包控制自己的移动。这是一种很自然的方法，当然还有其它的方法也可以完成这个功能。</p>
<h1 id="3-用户消息的内容"><a href="#3-用户消息的内容" class="headerlink" title="3.用户消息的内容"></a>3.用户消息的内容</h1><p>基于half-life引擎的游戏用户消息都很简单，只需要封装在一个包含几个关键成员的结构中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">usercmd_s</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="comment">// Interpolation time on client</span></span><br><span class="line">    short lerp_msec;  </span><br><span class="line">    <span class="comment">// Duration in ms of command</span></span><br><span class="line">    <span class="keyword">byte</span> msec;    </span><br><span class="line">    <span class="comment">// Command view angles.</span></span><br><span class="line">    <span class="keyword">vec3_t</span> viewangles;  </span><br><span class="line">    <span class="comment">// intended velocities</span></span><br><span class="line">    <span class="comment">// Forward velocity.</span></span><br><span class="line">    <span class="keyword">float</span> forwardmove;  </span><br><span class="line">    <span class="comment">// Sideways velocity.</span></span><br><span class="line">    <span class="keyword">float</span> sidemove;   </span><br><span class="line">    <span class="comment">// Upward velocity.</span></span><br><span class="line">    <span class="keyword">float</span> upmove;  </span><br><span class="line">    <span class="comment">// Attack buttons</span></span><br><span class="line">    <span class="keyword">unsigned</span> short buttons; </span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// Additional fields omitted...</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125; <span class="keyword">usercmd_t</span>;</span><br></pre></td></tr></table></figure>

<p>结构中最关键的变量时msec,viewangles,forward,side,upmove和buttons。msec表示这个命令执行对应的毫秒数（也就是上面提到的“frametime”）。viewangles是一个三维向量，表示玩家的朝向。forward,side和upmove表示玩家是否通过键盘、鼠标或控制杆控制移动。最后，buttons这个字段包含一个或多个比特，标志玩家是否按着某些按键。</p>
<p>基于C/S架构的游戏采用以上数据结构运行如下：客户端创建命令并发送到服务器，服务器响应这些命令并把更新了的世界和物体位置信息发回客户端，客户端收到以后进行渲染。这种方式非常简单，但是在实际应用中效果差强人意，用户会感觉到网络连接带来的明显延迟。这主要是由于客户端完全没有逻辑操作，发出消息以后就等待服务器响应。如果客户端跟服务器有500ms的延迟，客户端执行了操作到看到操作的结果就需要500ms，这种延迟在局域网通常可以接受（因为通常延迟比较小），但在因特网上是没法接受的</p>
<h1 id="4-客户端预测"><a href="#4-客户端预测" class="headerlink" title="4.客户端预测"></a>4.客户端预测</h1><p>有一种方法可以改善这种情况：客户端本地即时执行移动操作，假定服务器即时通知客户端可以执行操作，这种方法可以称为客户端预测。</p>
<p>采用客户端运动预测以后，客户端就不再是一个“小型客户端”，不再单单响应服务器命令；但也不是说客户端可以像没有中央服务器的p2p游戏完全自治。服务器仍然在运行并保证在客户端跟服务器运行结果不一致的情况下纠正客户端错误的模拟。由于网络延迟，修正在一个网络传输周期以后才会执行，这个时候纠正信息通常已经过期，这样会导致明显的位置漂移，因为客户端收到的修正信息是过去某个时间的。</p>
<p>为了使客户端运动预测有效，我们采用以下方法：还是客户端采样并生成命令发送到服务器，但是每个包含生成时间的命令在客户端本地存起来并在预测算法中使用。</p>
<p>预测的过程中，我们把服务器确认的移动信息作为开始，这样客户端就可以确定服务器执行上次命令以后游戏中玩家的准确信息（比如位置）。如果网络有延迟，这个确认命令也会有一定延迟。假设客户端运行帧率为50fps，网络延时为100ms，这样在客户端收到服务器的确认命令的时候，本地命令队列中已经有5条信息，这5条信息被用来执行客户端预测。假设执行完全预测【1】客户端在收到来自服务器的最新信息后，就开始按照与服务器相同的逻辑执行本地消息队列中的5个命令。这些命令执行以后得到当前状态（最重要的是位置），然后根据玩家的状态信息渲染当前帧。</p>
<p>在半条命这个游戏中，客户端跟服务器采用相同的代码来计算移动，这样可以减小客户端预测跟服务器之间的误差。这些代码位于HLSDK中的pm_shared/（意思是“player movement shared”）。这段代码的输入是玩家操作和客户端的初始状态，输出是玩家操作以后的状态。客户端算法大致如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&quot;from state&quot; &lt;- state after last user command acknowledged by the server;</span><br><span class="line"></span><br><span class="line">&quot;command&quot; &lt;- first command after last user command acknowledged by server;</span><br><span class="line"></span><br><span class="line">while (true)</span><br><span class="line">&#123;</span><br><span class="line">    run &quot;command&quot; on &quot;from state&quot; to generate &quot;to state&quot;;</span><br><span class="line">    if (this was the most up to date &quot;command&quot;)</span><br><span class="line">    break;</span><br><span class="line"></span><br><span class="line">    &quot;from state&quot; &#x3D; &quot;to state&quot;;</span><br><span class="line">    &quot;command&quot; &#x3D; next &quot;command&quot;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>玩家的初始状态和预测结果用来渲染场景。命令的执行过程就是：将玩家状态复制到共享数据结构中，执行玩家操作（执行hlsdk中pm_shared中的共用代码），然后将结果复制到目标状态（to state）</p>
<p>这个系统中有几个需要注意的地方，首先，由于网络延迟，客户端又在不停地以一定速度（客户端帧率）生成命令，一个命令通常会被客户端多次执行，知道得到服务器的确定以后将其从命令列表中删除（这就是半条命中的滑动窗口）。首先要考虑的是如何处理共享代码中生成的声效和动画效果。因为命令可能会被多次执行，预测位置的过程被多次执行的时候要注意避免重声等不正确的效果。另外，服务器也要避免客户端意见预测的效果。然而，客户端必须重新运行旧的命令，否则就没法根据服务器来纠正客户端的预测错误。解决方法很简单：客户端将没有执行的客户端命令进行标记，如果这些命令在客户端第一次执行，则播放相应的效果。</p>
<p>另外需要注意的是服务器不处理，只有客户端才有的一些数据；如果没有这种类型的数据，我们可以如上面所述，以服务器第一条消息作为起点进行预测得到下一帧状态（包括用来渲染的位置信息）。然而，如果有些逻辑是纯客户端的，服务器不会处理（比如玩家蹲下来眼睛的位置-然而这也不是纯客户端信息，因为服务器也会处理这个数据），这种情况下我们需要将预测的中间结果存起来。可以用一个滑动窗口完成这项工作，其中“开始状态”是开始，以后每次执行一个玩家命令预测完成后，填写窗口中的下一个状态；当服务器通知某个命令被接受并执行以后，从窗口中查找服务器处理的是哪条命令并将相应的数据传到下一个帧的“起始状态”</p>
<p>到此为止，我们描述了客户端的运动预测。quakeworld2中采用了这种类型的预测</p>
<h1 id="5-开火过程中的客户端预测"><a href="#5-开火过程中的客户端预测" class="headerlink" title="5.开火过程中的客户端预测"></a>5.开火过程中的客户端预测</h1><p>上面描述的系统可以很自然地用于武器开火效果预测。客户端玩家需要记录一些状态，比如身上有哪些武器，正在使用的是哪一个，每把武器都还剩多少弹药。有了这些信息，开火逻辑可以建立在运动逻辑上面，只需要在客户端和服务器使用的命令里面加上玩家开火的按键信息。在半条命中，为了简单，武器开火逻辑代码也跟运动代码一样也作为“共享代码”。所有会影响到武器状态的变量，比如弹药、下次可开火时间、正在播放那个武器动画，都作为服务器的状态，这些状态会通知给客户端用来预测武器状态。</p>
<p>客户端武器开火预测包括预测武器切换、部署、手枪皮套。这样，玩家会感觉游戏中的移动和武器状态100%受他控制。这在减小网络延迟给玩家带来的不爽上面迈出了一大步。</p>
<h1 id="6-一些工作"><a href="#6-一些工作" class="headerlink" title="6.一些工作"></a>6.一些工作</h1><p>服务器需要将必要的字段发给客户端，并且处理很多中间状态，有人可能有这样的疑问，为什么不把服务器逻辑取消，让客户端广播自己的位置，也就是将所有的移动、开火逻辑放在客户端。这样，客户端就会给服务器发送类似这样的结果报告：“我在X位置，我爆了玩家2的脑袋”。如果客户端可信的话，这样做是可以的，很多军方仿真系统就是这样做的（他们是一个封闭系统，所有客户端都可信）。点对点的游戏也是这么做的。对于半条命来说不可以这样做，因为客户端可能“欺骗”服务器。如果我们以这种方法封装状态数据，就会诱导玩家破解客户端【3】。对于我们的游戏来说这样做奉献太大，我们还是选择采用服务器模式来做校验。</p>
<p>客户端进行运动和武器效果预测是非常可行的。例如quake3就支持这样的预测。这个系统需要注意一点，在判断目标的时候需要考虑到延迟（比如即时射击武器）。换句话说，虽然你看到自己用\即时\武器进行了射击，你自己的位置也是最新的，射击结果仍然跟延迟有关。例如，如果你射击一个玩家，这个玩家沿与你实现垂直的方向奔跑，假设你客户端延迟为100ms，玩家奔跑速度是500单位每秒，这样你需要瞄准玩家前方50单位才能准确击中。延迟越大，就需要更大的提前量。靠感觉弥补延迟太困难了。为了减轻这种效果，quake3对你的射击播放一个短音来进行确定。这样，玩家可以算出快速发射武器的时候需要多大的提前量，同时调整提前量直到听到稳定的音调串。如果延迟比较大，而你的对手又在不断躲避，就很难获得足够的反馈判断。如果延迟也不断变化，就更难了。</p>
<h1 id="7-目标的显示"><a href="#7-目标的显示" class="headerlink" title="7.目标的显示"></a>7.目标的显示</h1><p>影响玩家游戏体验的另一个重要方面是客户端如何渲染其它玩家。两种基本的判断机制是：外推法和内插法【4】</p>
<p>外推法把其它玩家/物体看作一个点，这个点开始的位置、方向、速度已知，沿着自己的弹道向前移动。因此，假设延时是100ms，最新的协议通知客户端这个玩家奔跑速度是500单位每秒，方向垂直于玩家视线，客户端就可以假设事实上这个玩家当前实际的位置已经向前移动了50个单位。客户端可以在这个外推的位置渲染这个玩家，这样本地玩家就差不多可以正确瞄准。</p>
<p>外推法的最大缺点是玩家的移动并不是完全弹道的，而是不确定的并且高”jerk”【5】。大部分FPS游戏采用非现实的玩家系统，玩家可以随时转弯，可以在任意角度作用不现实的加速度，因此外推法得到的结果经常是错误地。开发者可以通过限制外推时间来减轻外推误差（比如quake限制不能超过100ms）。这种限制使得在客户端收到玩家正确位置以后，纠错不至于太大。当前大部分玩家的网络延迟高于150ms，玩家必须对游戏中的其他玩家进行外推以便正确击中。如果别的玩家因为外推错误，被服务器拉回，游戏体验将非常差。</p>
<p>另一种方法叫插值法。插值法可以这样理解：客户端物体实际移动位置总是滞后一段时间。举个例子，如果服务器每秒同步10次世界信息，客户端渲染的时候会有100ms滞后。这样，每一帧渲染的时候，我们通过最新收到的位置信息和前100ms的位置信息（或者上一帧渲染位置）进行差值得到结果。我们每收到一个物体位置的更新信息，（每秒10个更新意味着每100ms收到一个更新）接下来的100ms我们就可以朝这个新的位置移动。</p>
<p>如果一个更新包没有收到，有2种处理方法：第一、用上面介绍的外推法（有可能产生较大误差）；第二、保持玩家位于当前位置直到收到下一个更新包（会导致玩家移动顿挫）</p>
<p>内插法的大致过程如下：</p>
<ol>
<li><p>每个更新包包含生成的服务器时间戳【6】</p>
</li>
<li><p>根据客户端当前时间，客户端通过减去时间差（100ms）计算 一个目标时间</p>
</li>
<li><p>如果计算得到的目标时间在上一个更新时间和上上个更新时间之间，这些时间戳可以决定目标时间在过去的时间间隙中的情况</p>
</li>
<li><p>目标时间情况用来通过插值计算结果（如位置、角度）</p>
</li>
</ol>
<p>上面提到的插值法，本质上是客户端缓存了接下来100ms的数据。对于每一个周围的玩家，他们都位于过去某个时间的位置，根据每一个具体的时间点进行插值。如果偶尔发生丢包，我们就将插值时间延长到200ms。这样我们就可以忽略一次更新（假设同步频率还是10次每秒），玩家还可以移动到合理的目标位置，这样进行插值通常不会有什么问题。当然，插值多少时间需要权衡，因为这种方法是用延时（玩家更难击中）来换取平滑。</p>
<p>另外，上述插值方法（客户端通过2个更新信息插值并且朝最新更新位置移动）需要服务器更新信息间隔固定。对于所谓的“视觉效果因素”，这种方式很难处理，“视觉效果因素”是这样的：假设我们插值的物体是弹球（这种模型可以准确描述某些玩家）。极端情况下，球或者在空中，或者正在碰地板。然而，通常情况下球在这两种状态之间。如果我们只插值上一个位置，这个位置可能既不在地面上，也不是最高点，这样，弹球弹的效果就被平滑掉了，好像永远没有弹到地面一样。这是一个经典问题，增加采样率可以减轻这种影响，但是仍然有可能我们采样不到球在地面的点跟最高点，这些点会给平滑掉。</p>
<p>另外，不同用户网络状况不同，强迫每个用户都以固定速度更新（比如每秒10次）效果不是很好，在半条命中，用户每秒可以请求任意数量的更新包（没有限制）。这样，高速网络用户可以每秒更新50次，只要用户愿意。半条命的默认设置是每秒每个用户（以及游戏中其它物体）发送20次更新，以100ms为时间窗口进行插值。【7】</p>
<p>为了避免“反弹球”平滑问题，我们在插值的过程中采用了一个不同的算法，这种算法中我们对每一个可能插值的物体记录了一个完整的“历史位置”信息。</p>
<p>历史位置信息记录了物体的时间戳、远点、角度（以及其它我们需要插值计算的数据）。我们每收到一个服务器的更新，我们就创建一条包含时间戳的记录，其中包含原始位置、角度信息。在插值过程中，我们用上面的方法计算目标时间，然后搜索位置历史信息，找到包含目标时间的记录区间。然后用找到的信息插值计算当前帧的位置。这样我们就可以平滑跟踪到包含所有采样点的曲线。如果客户端帧率比服务器更新频率大，我们就可以将采样点平滑处理，减小上面提到的平滑处理带来的问题（当然没法避免，因为采用频率限制，而世界本身是连续的）。</p>
<p>需要注意的是，上面提到的插值方法使用的时候，物体有时候会被服务器拉回，而不是快速移动。当然我们也可以平滑地将物体移动一段较长的距离，这样看起来物体移动很快。更新的过程中我们可以设一个标志表示不插值或清除历史记录，或者如果起始点与目标点距离过长，我们就认为数据不正常。这种情况我们就将物体直接拉过去。并以这个位置为起始点进行插值。</p>
<h1 id="8-延迟补偿"><a href="#8-延迟补偿" class="headerlink" title="8.延迟补偿"></a>8.延迟补偿</h1><p>插值也会带来延迟，所以考虑延迟补偿的过程中需要理解插值过程。玩家看到的别的物体是经过插值计算出来的，所以插值过程中需要考虑在服务器上玩家的目标是否正确。</p>
<p>延迟补偿是服务器执行的一种策略，当服务器收到客户端命令并执行的过程中，根据客户端的具体情况进行归一。延迟补偿可以看做服务器处理用户命令的时候回退一段时间，退到客户端发送命令时候的准确时间。算法流程如下：</p>
<ol>
<li><p>服务器执行客户端命令之前执行以下操作：</p>
<ol>
<li>计算玩家正确的延迟</li>
<li>对每个玩家，从服务器历史信息中找到发送给玩家信息和收到玩家响应的信息。</li>
<li>对于每一个玩家，将其拉回到这个更新时间（插值得到的精确时间）中执行用户命令。这个回退时间需要考虑到命令执行的时候的网络延时和插值量【8】</li>
</ol>
</li>
<li><p>执行玩家命令（包括武器开火等。）</p>
</li>
<li><p>将所有移动的、错位的玩家移动到他们当前正确位置。</p>
</li>
</ol>
<p>注意：我们把时间往后推算的时候，需要考虑那个时候玩家的状态，比如玩家是或者还是已经已经死掉，玩家是否处于躲避状态。执行运动补偿以后，玩家就可以直接瞄准目标进行设计，而不需要计算一个提前量。当然，这种方案是游戏中的权衡设计。</p>
<h1 id="9-游戏涉及中延迟补偿的使用"><a href="#9-游戏涉及中延迟补偿的使用" class="headerlink" title="9.游戏涉及中延迟补偿的使用"></a>9.游戏涉及中延迟补偿的使用</h1><p>采用延迟补偿以后，每个玩家游戏的过程中感觉不到明显延迟。在这里需要理解可能会产生一些矛盾和不一致。当然，验证服务器和无逻辑的客户端老系统也会有自相矛盾的情况。最后，这个这种事游戏设计决定的。对于半条命，我们相信采用延迟补偿是正确的游戏决定。</p>
<p>老系统的一个问题是，由于网络延迟，目标需要有一个提前量。瞄准敌人进行射击几乎总是不能击中。这种不一致导致射击很不真实，响应也不可控制。</p>
<p>采用延迟补偿以后带来的是另一种形式的不一致。对于大部分玩家，他们只需要专注于得到更多的射击技能来武装他们（当然他们也是需要瞄准的）。延时补偿使得玩家只需要直接瞄准他的目标并按下开火按钮即可（对于即时击中武器【9】）。不一致也时有发生，但是是在击中以后。</p>
<p>例如，如果一个延时比较大的玩家击中一个延时比较小的玩家并且得到一分，低延时的玩家会感觉高延时玩家“在角落里被击中”【10】。这种情况下，低延迟玩家可能已经从角落里冲出，而高延时玩家看到的是过去的信息。每一个有延迟的玩家都有一个朝向别的玩家的直的视线，直的视线指向一个瞄准点然后开火。这个时候，低延时的玩家可能已经跑到角落里并且蹲在一个箱子后面，如果高延迟玩家延迟比较大，比如500ms，这是经常发生的；这样当高延时玩家的命令传到服务器的时候，已经隐藏起来的玩家需要取一个历史位置并计算是否击中，在这种极端情况下，低延时玩家会觉得他再角落里被击中了。然而，对于高延时玩家来说，他是正对着别的玩家开火的。从游戏设计的角度来讲，我们需要这样决定：让每个玩家即时与世界交互并开火。</p>
<p>此外，在正常战斗中，上面提到的不一致并不明显。对于第一人称射击游戏，有两种典型情况。第一、考虑两个玩家直线跑向对方并且开火；这种情况下，延时补偿只会把玩家在移动直线上往后拉。被击中的玩家看他的射击者在前方，这样就不会有“子弹拐到角落里”的情况发生。</p>
<p>第二种情况是两个玩家中的一个射击，另外一个玩家在垂直于第一个玩家视线的方向冲锋。这种情况下的解决问题的原理与刚才不同。刚才提到的冲锋的玩家视野差不多是90°（至少第一人称射击游戏是这样），因此，这个玩家看不到正在射击他的那个人。因此他被击中也不会感觉奇怪或者错误（谁让你在空旷区域狂奔呢，活该）。当然，如果你开发的是一个坦克游戏，或者在你的游戏中玩家朝一个方向跑的时候可以看到别的方向，错误可能就会比较明显，你可能发现玩家设计方向不对。</p>
<h1 id="10-总结"><a href="#10-总结" class="headerlink" title="10.总结"></a>10.总结</h1><p>延迟补偿是当前动作游戏改善延迟影响的一种方法。是否采用这种方法取决于游戏设计者，因为如何设计直接影响到游戏的体验。对于把那条命、军团要塞、cs这样的游戏，延迟补偿所带来的效果提升显著大于其带来的错误。</p>
<h1 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h1><p>【1】在半条命引擎中，预测的过程中允许一定的延迟，但不能容忍实际网络延迟这么大的延迟。通过调整参数，我们可以控制预测过程中的延迟，这个参数pushlatency是一个负数，以毫秒为单位表示预测过程中的延迟。如果这个值大于（绝对值）实际网络延迟，这时预测就是完全的预测（译注：客户端服务器完全同步）。这种情况下玩家感觉不到任何延迟。实际应用中，一些人错误地认为参数pushlatency应该设为实际网络延迟的一半，这种情况下玩家移动仍然有网络延迟一半的延迟（感觉类似于冰面移动）。基于这个原因，实际应用总应该总是采用完全预测，pushlatency这个变量应该从半条命引擎中移除</p>
<p>【2】<a href="http://www.quakeforge.net/files/q1source.zip" target="_blank" rel="noopener">http://www.quakeforge.net/files/q1source.zip</a> (Return)</p>
<p>【3】关于作弊和反作弊的问题超出了本篇文章讨论的范围</p>
<p>【4】虽然混合纠正方法也可以使用</p>
<p>【5】“jerk”用来度量使玩家改变加速度的作用的快慢</p>
<p>【6】本文假设计算连接延时的时候客户端与服务器完全同步，也就是说，每次更新的时候客户端收到服务器发过来的时间被直接当做客户端的时间使用。这样，客户端跟服务器完全匹配，只是客户端稍微晚一点（晚多少取决于延时多少）。平滑客户端时钟差值可以有很多方法。</p>
<p>【7】更新时间间隔没必要是固定的。因为对于剧烈运动的游戏，如果带宽不够，很有可能客户端发过来的数据超过了处理能力。如果采用固定更新间隔，在发完一个更新包以后就需要等待一个固定更新周期时间以后再发下一个包。这种逻辑不能很好地使用带宽。因此，服务器发给每个客户端数据包以后，应该自己决定下一个包什么时候发，决定的依据是用户的带宽、用户设置的每秒更新频率。如果用户要求更新20次每秒，那么需要等待50ms以后下个更新包才能发送。如果激活了带宽限制（而服务器帧率又足够高），我们可能就需要等待比如61ms（或其他值）以后发送下一个更新包。因此，半条命游戏数据包发送间隔是随机的。基于服务器的这种情况，将启动点作为一个变量，移动到最新目标点进行插值这种方法效果欠佳。</p>
<p>【8】半条命代码中usercmd_t结构中变量lerp_msec前面描述过。</p>
<p>【9】对于发射导弹的武器，延迟补偿有更多需要解决的问题。假如\导弹是由服务器处理的，那么导弹应该位于哪个时间区间？每次导弹准备发射的时候，是否需要把每个玩家往后拉一段时间的？如果是这样，那么需要往后拉多少？这些问题是需要考虑的。在半条命中，为了避免这种问题，我们对导弹不进行延迟补偿（这并不意味着客户端不进行声音预测，只是实际的导弹不进行延迟补偿）。</p>
<p>【10】用户社区通常采用这种情况来描述不一致性。</p>
<ul>
<li><a href="https://developer.valvesoftware.com/wiki/Latency_Compensating_Methods_in_Client/Server_In-game_Protocol_Design_and_Optimization" target="_blank" rel="noopener">https://developer.valvesoftware.com/wiki/Latency_Compensating_Methods_in_Client/Server_In-game_Protocol_Design_and_Optimization</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.igiven.com/dotnet-2020-02-02-Source-Multiplayer-Networking/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhepama">
      <meta itemprop="description" content="一个不专业的程序员,写着不专业的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IGiven">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/dotnet-2020-02-02-Source-Multiplayer-Networking/" class="post-title-link" itemprop="url">起源引擎网络同步模型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-02 08:00:00" itemprop="dateCreated datePublished" datetime="2020-02-02T08:00:00+08:00">2020-02-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-16 12:44:43" itemprop="dateModified" datetime="2020-07-16T12:44:43+08:00">2020-07-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/dotnet/" itemprop="url" rel="index"><span itemprop="name">dotnet</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Source引擎的多人游戏使用基于UDP通信的C/S架构。游戏以服务器逻辑作为世界权威，客户端和服务器通过UDP协议(20~30packet/s）通信。客户端从服务器接收信息并基于当前世界状态渲染画面和输出音频。客户端以固定频率发送操作输入到服务器。客户端仅与游戏服务器，而不是彼此之间通信。多人游戏必须处理基于网络消息同步所带来的一系列问题。</p>
<p>网络的带宽是有限的，所以服务器不能为每一个世界的变化发送新的更新数据包发送到所有客户端。相反，服务器以固定的频率取当前世界状态的快照并广播这些快照到客户端。网络数据包需要一定的时间量的客户端和服务器（RTT的一半）来往。这意味着客户端时间相对服务器时间总是稍有滞后。此外，客户端输入数据包同步到服务器也有一定网络传输时间，所以服务器处理客户端输入也存在延迟的。不同的客户端因为网络带宽和通信线路不同也会存在不同的网络延时。随着服务器和客户端之间的这些网络延迟增大, 网络延迟可能会导致逻辑问题。比如在快节奏的动作游戏中，在几毫秒的延迟甚至就会导致游戏卡顿的感觉，玩家会觉得很难打到对方玩家或运动的物体。此外除了带宽限制和网络延迟还要考虑网络传输中会有消息丢失的情况。</p>
<p><img src="../../assets/images/2020-02-02-Source_Multiplayer_Networking/83792-20170707175512800-299175149.png" alt="img"></p>
<p>为了解决网络通信引入的一系列问题，Source引擎在服务器同步时采用了数据压缩和延迟补偿的逻辑，客户端采用了预测运行和插值平滑处理等技术来获得更好的游戏体验。</p>
<h3 id="基本网络模型"><a href="#基本网络模型" class="headerlink" title="基本网络模型"></a>基本网络模型</h3><p>服务器以一个固定的时间间隔更新模拟游戏世界。默认情况下，时间步长为15ms，以66.66次每秒的频率更新模拟游戏世界，但不同游戏可以指定更新频率。在每个更新周期内服务器处理传入的用户命令，运行物理模拟步，检查游戏规则，并更新所有的对象状态。每一次模拟更新tick之后服务器会决定是否更新当前时间快照以及每个客户端当前是否需更新。较高的tickrate增加了模拟精度，需要服务器和客户端都有更多可用的CPU和带宽资源。客户通常只能提供有限的带宽。在最坏的情况下，玩家的调制解调器连接不能获得超过5-7KB /秒的流量。如果服务器的数据更新发送频率超过了客户端的带宽处理限制，丢包是不可避免的。因此客户端可以通过在控制台设置接受带宽限制，以告诉服务器其收到的带宽容量。这是客户最重要的网络参数，想要获得最佳的游戏体验的话必须正确的设置此参数。客户端可以通过设置cl_updaterate（默认20）来改变获得快照平的频率，但服务器永远不会发送比tickerate更多的更新或超过请求的客户端带宽限制。服务器管理员可以通过sv_minrate和sv_maxrate(byte/s)限制客户端的上行请求频率。当然快照更新同步频率都受到sv_minupdaterate和sv_maxupdaterate（快照/秒）的限制。</p>
<p>客户端使用与服务端tickrate一样的频率采样操作输入创建用户命令。用户命令基本上是当前的键盘和鼠标状态的快照。客户端不会把每个用户命令都立即发送到服务器而是以每秒（通常是30）的速率发送命令包。这意味着两个或更多个用户的命令在同一包内传输。客户可以增加与的cl_cmdrate命令速率。这可以提高响应速度，但需要更多的出口带宽。</p>
<p>游戏数据使用增量更新压缩来减少网络传输。服务器不会每次都发送一个完整的世界快照，而只会更新自上次确认更新(通过ACK确认)之后所发生的变化（增量快照)。客户端和服务器之间发送的每个包都会带有ACK序列号来跟踪网络数据流。当游戏开始时或客户端在发生非常严重的数据包丢失时, 客户可以要求全额快照同步。</p>
<p>用户操作的响应速度(操作到游戏世界中的可视反馈之间的时间)是由很多因素决定的，包括服务器/客户端的CPU负载，更新频率，网络速率和快照更新设置，但主要是由网络包的传输时间确定。从客户端发送命令到服务器响应, 再到客户端接收此命令对应的服务器响应被称为延迟或ping（或RTT）。低延迟在玩多人在线游戏时有显著的优势。客户端本地预测和服务器的延迟补偿技术可以尽量为网络较差的游戏玩家提供相对公平的体验。如果有良好的带宽和CPU可用，可以通过调整网络设置以获得更好的体验, 反之我们建议保持默认设置，因为不正确的更改可能导致负面影响大于实际效益。</p>
<h3 id="Enitiy插值平滑"><a href="#Enitiy插值平滑" class="headerlink" title="Enitiy插值平滑"></a>Enitiy插值平滑</h3><p>通常情况下客户端接收每秒约20个快照更新。如果世界中的对象（实体）直接由服务器同步的位置呈现，物体移动和动画会看起来很诡异。网络通信的丢包也将导致明显的毛刺。解决这个问题的关键是要延迟渲染，玩家位置和动画可以在两个最近收到快照之间的连续插值。以每秒20快照为例，一个新的快照更新到达时大约每50毫秒。如果客户端渲染延迟50毫秒，客户端收到一个快照，并在此之前的快照之间内插(Source默认为100毫秒的插补周期)；这样一来，即使一个快照丢失，总是可以在两个有效快照之间进行平滑插值。如下图显示传入世界快照的到达时间：</p>
<p><img src="../../assets/images/2020-02-02-Source_Multiplayer_Networking/83792-20170707175529456-2030374817.png" alt="img"></p>
<p>在客户端接收到的最后一个快照是在tick 344或10.30秒。客户的时间将继续在此快照的基础上基于客户端的帧率增加。下一个视图帧渲染时间是当前客户端的时间10.32减去0.1秒的画面插值延迟10.20。在我们的例子下一个渲染帧的时间是10.22和所有实体及其动画都可以基于快照340和342做正确的插值处理。</p>
<p>既然我们有一个100毫秒的延迟插值，如果快照342由于丢包缺失，插值可以使用快照340和344来进行平滑处理。如果连续多个快照丢失，插值处理可能表现不会很好，因为插值是基于缓冲区的历史快照进行的。在这种情况下，渲染器会使用外推法（cl_extrapolate 1），并尝试基于其已知的历史，为实体做一个基于目前为止的一个简单线性外推。外推只会快照更新包连续丢失（cl_extrapolate_amount）0.25秒才会触发，因为该预测之后误差将变得太大。实体内会插导致100毫秒默认（cl_interp 0.1）的恒定视图“滞后”，就算你在listenserver（服务器和客户端在同一台机器上）上玩游戏。这并不是说你必须提前预判动画去瞄准射击，因为服务器端的滞后补偿知道客户端实体插值并纠正这个误差。</p>
<p>最近Source引擎的游戏有cl_interp_ratioCVaR的。有了这个，你可以轻松，安全地通过设置cl_interp为0，那么增加的cl_updaterate的值（这同时也会受限于服务器tickrate）来减少插补周期。你可以用net_graph 1检查您的最终线性插值。</p>
<p>如果打开sv_showhitboxes，你会看到在服务器时间绘制的玩家包围盒，这意味着他们在前进的线性插值时期所呈现的播放器模式。</p>
<h3 id="输入预测"><a href="#输入预测" class="headerlink" title="输入预测"></a>输入预测</h3><p>让我们假设一个玩家有150毫秒的网络延迟，并开始前进。前进键被按下的信息被存储在用户命令，并发送至服务器。用户命令是由移动代码逻辑处理，玩家的角色将在游戏世界中向前行走。这个世界状态的变化传送到所有客户端的下一个快照的更新。因此玩家看到自己开始行动的响应会有150毫秒延迟，这种延迟对于高频动作游戏(体育，设计类游戏)会有明显的延迟感。玩家输入和相应的视觉反馈之间的延迟会产生一种奇怪的，不自然的感觉，使得玩家很难移动或精确瞄准。客户端的输入预测（cl_predict 1）执行是一种消除这种延迟的方法，让玩家的行动感到更即时。与其等待服务器来更新自己的位置，在本地客户端只是预测自己的用户命令的结果。因此，客户端准确运行相同的代码和规则服务器将使用来处理用户命令。预测完成后，当地的玩家会移动到新位置，而服务器仍然可以看到他在老地方。150毫秒后，客户会收到包含基于他早期预测用户命令更改服务器的快照。客户端会将预测位置同服务器的位置对比。如果它们是不同的，则发生了预测误差。这表明，在客户端没有关于其他实体的正确信息和环境时，它处理用户命令。然后，客户端必须纠正自己的位置，因为服务器拥有客户端预测最终决定权。如果cl_showerror 1开启，客户端可以看到，当预测误差发生。预测误差校正可以是相当明显的，并且可能导致客户端的视图不规则跳动。通过在一定时间（cl_smoothtime）逐渐纠正这个错误，错误可以顺利解决。预测误差平滑处理可以通过设置cl_smooth 0来关闭。预测只对本地玩家以及那些只收它影响的实体有效，因为预测的工作原理是使用客户端的操作来预测的。对于其他玩家没法做有效预测, 因为没有办法立即从他们身上得到操作信息。</p>
<h3 id="延迟补偿"><a href="#延迟补偿" class="headerlink" title="延迟补偿"></a>延迟补偿</h3><p>​    比方说，一个玩家在10.5s的时刻射击了一个目标。射击信息被打包到用户命令，该命令通过网络的方式发送至服务器。服务器持续模拟游戏世界，目标可能已经移动到一个不同的位置。用户命令到达服务器时间10.6时服务器就无法检测到射击命中，即使玩家已经在目标准确瞄准。这个错误需要由服务器侧进行延迟补偿校正。延迟补偿系统使所有玩家最近位置的历史一秒。如果在执行用户的命令，服务器预计在命令创建什么时间如下：</p>
<p>命令执行时间=当前服务器时间 - 数据包延迟 - 客户端查看插值</p>
<p>然后服务器会将所有其他玩家回溯到命令执行时的位置，他们在命令执行时间。用户指令被执行，并正确地检测命中。用户命令处理完成后，玩家将会恢复到原来的位置。由于实体插值包含在公式中，可能会导致意外的结果。服务器端可以启用sv_showimpacts 1，显示服务器和客户端射击包围盒位置差异：</p>
<p><img src="../../assets/images/2020-02-02-Source_Multiplayer_Networking/83792-20170707175552144-269867355.jpg" alt="img"></p>
<p>该画面在主机上设置延迟200毫秒(net_fakelag设置)时获取的，射击真实命中玩家。红色命中包围盒显示了客户端那里是100毫秒+插补周期前的目标位置。此后，目标继续向左移动，而用户命令被行进到服务器。用户命令到达后，服务器恢复基于所述估计的命令执行时间目标位置（蓝色击中盒）。服务器回溯演绎，并确认命中（客户端看到流血效果）。</p>
<p>因为在时间测量精度的误差客户端和服务器命中包围盒不完全匹配。对于快速移动的物体甚至几毫秒的误差也会导致几英寸的误差。多人游戏击中检测不是基于像素的完美匹配，此外基于tickrate模拟的运动物体的速度也有精度的限制。</p>
<p>既然击中检测服务器上的逻辑如此复杂为什么不把命中检查放在客户端呢？如果在客户端进行命中检查, 玩家位置和像素命中处理检测都可以精准的进行。客户端将只告诉服务器用“打”的消息一直打到什么样的玩家。因为游戏服务器不能信任客户端这种重要决定。因为即使客户端是“干净”的，并通过了Valve反作弊保护，但是报文可以被截获修改然后发送到游戏服务器。这些“作弊代理”可以注入“打”的消息到网络数据包而不被VAC被检测。</p>
<p>网络延迟和滞后补偿可能会引起真实的世界不可能的逻辑。例如，您可能被你看不到的目标所击中。服务器移到你的命中包围盒时光倒流，你仍然暴露给了攻击者。这种不一致问题不能通过一般化的防范解决，因为相对网络包传输的速度。在现实世界中，因为光传播如此之快，你，每个人都在你身边看到同一个世界，所以你才你没有注意到这个问题。</p>
<h3 id="网络视图NET-Graph"><a href="#网络视图NET-Graph" class="headerlink" title="网络视图NET_Graph"></a>网络视图NET_Graph</h3><p>Source引擎提供了一些工具来检查您的客户端连接速度和质量。使用net_graph 2可以启用相关的视图。下面的曲线图中，第一行显示每秒当前的渲染的帧，您的平均延迟时间，以及的cl_updaterate的当前值。第二行显示在最后进来的数据包（快照），平均传入带宽和每秒接收的数据包的字节大小。第三行显示刚刚传出的数据包（用户命令）相同的数据。</p>
<p><img src="../../assets/images/2020-02-02-Source_Multiplayer_Networking/83792-20170707175609190-66628227.jpg" alt="img"></p>
<p>默认的网络设置是专门为通过互联网连接的游戏服务器设计的。可以适用大多数客户机/服务器的硬件和网络配置工作。对于网络游戏，应该在客户端上进行调整，唯一的控制台变量是“rate”，它定义客户端可用的字节/网络连接带宽。</p>
<p>在一个良好的网络环境中，服务器和所有客户端都具有必要的硬件资源可用，可以调整带宽和更新频率设置，来获得更多的游戏精度。增加tickrate通常可以提高运动和射击精度，但会消耗更多的服务器CPU资源。tickrate 100运行的服务器的负载大概是tickrate 66运行时的约1.5倍, 因此如果CPU性能不足可能会导致严重的计算滞后，尤其是在玩家数量比较多的时候。建议对具有更高tickrate超的游戏服务器预留必要的CPU资源。</p>
<p>如果游戏服务器使用较高tickrate运行时，客户端可以在带宽可用的情况下增加他们的快照更新率（的cl_updaterate）和用户命令速率（的cl_cmdrate）。快照更新速率由服务器tickrate限制，一台服务器无法发送每个时钟周期的一个以上的更新。因此，对于一个tickrate66服务器，为的cl_updaterate最高的客户价值，将是66。如果你增加快照率遇到，你必须再次打开它。与增加的cl_updaterate你也可以降低画面插值延迟（cl_interp）。默认的插值延迟为0.1秒(默认的cl_updaterate为20) 视图内插延迟会导致移动的玩家会比静止不动的玩家更早发现对方。这种效果是不可避免的，但可以通过减小视图内插值延迟来减小。如果双方玩家正在移动，画面滞后会延迟影响双方玩家,双方玩家都不能获利。快照速率和视图延迟插值之间的关系如下：</p>
<p>插补周期= MAX(cl_interp，cl_interp_ratio /cl_updaterate)</p>
<p>可以设置cl_interp为0，仍然有插值的安全量。也可以把cl_updaterate增加，进一步降低你的插补周期，但不会超过更新tickrate(66)或客户端的网络处理能力。</p>
<h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h3><p>不要瞎改终端配置除非你完全确定你在干嘛</p>
<p>​    如果客户端和服务器没有足够CPU和网络资源，绝大多数所所谓高性能优化都是起负面作用</p>
<p>不要关闭画面插值和延迟补偿</p>
<p>​    这样并不能代理移动和设计精准度提升</p>
<p>优化设置可能不会对每个客户端都有效</p>
<p>如果是你是在游戏里或者SourceTv里第一视角观看你看到的画面和玩家可能不一样</p>
<p>观战者的画面没有延迟补偿</p>
<p><a href="https://developer.valvesoftware.com/wiki/Source_Multiplayer_Networking" target="_blank" rel="noopener">https://developer.valvesoftware.com/wiki/Source_Multiplayer_Networking</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.igiven.com/dotnet-2020-02-02-net-sync-client-server-game-architecture/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhepama">
      <meta itemprop="description" content="一个不专业的程序员,写着不专业的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IGiven">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/dotnet-2020-02-02-net-sync-client-server-game-architecture/" class="post-title-link" itemprop="url">快节奏多人游戏同步(1)-ClientServer架构</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-02 08:00:00" itemprop="dateCreated datePublished" datetime="2020-02-02T08:00:00+08:00">2020-02-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-16 12:44:43" itemprop="dateModified" datetime="2020-07-16T12:44:43+08:00">2020-07-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/dotnet/" itemprop="url" rel="index"><span itemprop="name">dotnet</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="PART-1-概述"><a href="#PART-1-概述" class="headerlink" title="PART 1 概述"></a>PART 1 概述</h2><p>本文是关于探索快节奏多人游戏的技术和算法系列的第一篇，因此对多人游戏概念非常熟悉的同学可以随意的跳过这一篇就好啦～因为接下来只是一些介绍性质的讨论。。。</p>
<p>任何类型的游戏开发都是某种挑战，然而在多人游戏中我们还有更多全新的问题函待解决～最最 Interesting 的地方在于其核心问题其实是人类和物理！- - 好吧其实是作弊和地理限制造成的网络延时。。</p>
<h2 id="PART-2-反作弊"><a href="#PART-2-反作弊" class="headerlink" title="PART 2 反作弊"></a>PART 2 反作弊</h2><p>所有的一切的起源都是作弊。</p>
<p>作为一个游戏开发者，你一般不会去担心有人在你的单人游戏中去作弊 - 因为他的行为不会给其他人带来影响，一个作弊的玩家可能并不会按你设计的套路去进行游戏，但是游戏是他的，他们有权利去选择怎么去玩。</p>
<p>多人游戏则不同。在任何的有竞争关系的游戏中，一个作弊玩家不仅仅给自己带来了更好的体验，他也毁了其他的玩家的游戏。作为开发者，你可能希望避免出现这样的情况，因为这会让玩家流失。</p>
<p>为了防止作弊，有很多事可以去做，但是最重要最（可能也是唯一有意义的）的事非常简单：不要相信玩家。就做最坏的打算：所有玩家都想要作弊。</p>
<h2 id="PART-3-权威服务器和静默客户端"><a href="#PART-3-权威服务器和静默客户端" class="headerlink" title="PART 3 权威服务器和静默客户端"></a>PART 3 权威服务器和静默客户端</h2><p>有一个非常简单的解决方案 - 你将游戏中所有的逻辑都放在你控制的服务器来做，而客户端只是游戏的旁观者，换句话说，你游戏的客户端把输入（按键，命令）发送到服务器，服务器来运行这个游戏，然后你把结果返回给客户端。这就是常说的权威服务器，因为游戏世界中发生的一切都在服务器中进行。</p>
<p>当然，你的服务器还是可能被发现漏洞，但是这就不属于我们要谈论的范围了。使用权威服务器可以防止很多的漏洞，比如，服务器不信任玩家的在客户端的血量，客户端想要作弊，把本地的血量调到10000%，但服务器知道血量只有10% - 当玩家被攻击的时候它还是会死掉，不管客户端的血量是多少。</p>
<p>服务器同样不信任玩家的位置。你可能会这样做，在这一秒你告诉服务器“我在（10，10）”，然而下一秒你告诉服务器“我在（20，10）”，这样就可以穿过一堵墙或者超快速的移动。但是，权威服务器知道玩家在（10，10），当客户端告知服务器他要往右动一格的时候，客户端的位置会由服务器来处理，将位置更新为（11，10），然后告知玩家“你在（11，10）”。如下图所示:</p>
<p><img src="../../assets/images/2020-02-02-client-server-game-architecture/fpm1-01.png" alt="A simple client-server interaction."></p>
<p>总的来说，游戏的状态由服务器独自管理。客户端将动作发送给服务器，服务器来周期性地更新游戏状态，然后将新的游戏状态发送给客户端，客户端对结果进行渲染呈现。。</p>
<h2 id="PART-4-考虑网络问题"><a href="#PART-4-考虑网络问题" class="headerlink" title="PART 4 考虑网络问题"></a>PART 4 考虑网络问题</h2><p>上面的处理方式对于回合制的游戏非常适合，比如策略游戏或者棋牌类的游戏。它在LAN中也能工作的很好，在这种情况下，通信是瞬发的。但是对于一些对实时性要求很高的游戏，而且在internet环境中，这种解决方案就会出问题了。</p>
<p>下面来谈一些物理的问题。假如你在旧金山，连接了一个在纽约的服务器，两地相距4000km或者2500英里（大概是里斯本到莫斯科的距离）。任何东西都不能比光快吧，即使是Internet上的数据（数据传播的底层可能是光的脉冲，线缆中的电子，或者是电磁波），光传播的速度大概是300000km/s，所以传播4000km需要13ms。</p>
<p>这听起来可能很快，但这实际是最乐观的情况 - 假设数据传播的速度是光速，沿着直线传播，这些通常是不可能的。在真实情况下，数据是由无数个路由经过一系列的跳（在计算机网络里的属于叫做hops）进行传播的，而且大部分的传播速度都达不到光速；路由在传播的时候也会产生一些延迟，因为包必须被打包，检查和分发。</p>
<p>所以保险起见，我们假设数据从客户端到服务器需要50ms，这接近最好的场景了 - 当你在纽约而服务器在东京呢？假设网络因为什么原因发生阻塞了呢？100ms，200ms，500ms的延迟也是有可能的。</p>
<p>回到我们的例子，你的客户端将输入“我按下了向右的按键”发给服务器，服务器在50ms之后获取了数据，现在假设服务器能够立即响应并且将结果返回，那么客户端在50ms之后获得新的游戏状态“你现在在（1，0）”。</p>
<p>从你的视角来看，情况是这样的：你按下了向右的按键，但是什么事都没发生，直到一百年后你的角色向右移动了一格。这样的延迟是显而易见的，当然延迟半秒不仅仅是显而易见，它让整个游戏没法玩了。</p>
<h2 id="PART-5-总结"><a href="#PART-5-总结" class="headerlink" title="PART 5 总结"></a>PART 5 总结</h2><p>通过网络连接的多人游戏是超级有趣的，但是引入了一系列的难题和挑战。权威服务器架构能够防止很多的作弊，但是直接用这种方法会让游戏的响应变得迟缓。</p>
<p>在下面的文章，我们会介绍我们怎么围绕权威服务器来建立一个系统，能够最小的减少玩家的延迟体验，就像在玩单机游戏一样顺畅。</p>
<ul>
<li><a href="http://www.gabrielgambetta.com/client-server-game-architecture.html" target="_blank" rel="noopener">http://www.gabrielgambetta.com/client-server-game-architecture.html</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.igiven.com/dotnet-2020-02-02-net-sync-client-side-prediction-and-server-reconciliation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhepama">
      <meta itemprop="description" content="一个不专业的程序员,写着不专业的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IGiven">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/dotnet-2020-02-02-net-sync-client-side-prediction-and-server-reconciliation/" class="post-title-link" itemprop="url">快节奏多人游戏同步(2)-客户端预测与服务器校对</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-02 08:00:00" itemprop="dateCreated datePublished" datetime="2020-02-02T08:00:00+08:00">2020-02-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-16 12:44:43" itemprop="dateModified" datetime="2020-07-16T12:44:43+08:00">2020-07-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/dotnet/" itemprop="url" rel="index"><span itemprop="name">dotnet</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="PART-1-概述"><a href="#PART-1-概述" class="headerlink" title="PART 1 概述"></a>PART 1 概述</h2><p>在第一篇文章中，我们介绍了一种权威服务器的C-S模型，在这种模型中，客户端只将输入发送到服务器中，当收到来自服务器的游戏状态更新的时候再将结果渲染出来。</p>
<p>单纯地依赖这种模型会导致玩家输入命令和画面更新之间的延迟感，比如，当玩家按下向右的按钮，然后玩家等了半秒钟才开始移动，因为首先客户端需要把输入传给服务器，然后服务器处理了出入之后计算出新的游戏状态，然后再将新的游戏状态传回给客户端。</p>
<p><img src="../../assets/images/2020-02-02-net-sync-client-side-prediction-and-server-reconciliation/fpm2-01.png" alt="Effect of network delays."></p>
<p>在实际的网络环境中，延迟可能会达到零点几秒，这时游戏就有点感觉延迟了，最坏的情况是直接没法玩了。在这篇文章中，我们将找到减小这种延迟感的方法，甚至能够消除这种延迟。</p>
<h2 id="PART-2-客户端预测"><a href="#PART-2-客户端预测" class="headerlink" title="PART 2 客户端预测"></a>PART 2 客户端预测</h2><p>虽然存在着作弊的玩家，但是大部分时候服务器是处理有效访问的（来自非作弊玩家的），这也意味着服务器收到大部分的输入都是有效的，而且游戏状态的更新也是按照预期的，也即是说：如果你的角色在（10，10），然后方向键右被按下了，那么你的角色就会移动到（11，10）。</p>
<p>我们可以利用这一点，如果游戏世界的确定性足够（给定一个游戏状态和一些列的输入，得到的结果是完全可预测的）。</p>
<p>现在假设有100ms的延迟，角色移动一格需要花费100ms，使用之前说的实现方式，那么整个动作完成需要花费200ms:</p>
<p><img src="../../assets/images/2020-02-02-net-sync-client-side-prediction-and-server-reconciliation/fpm2-02.png" alt="Network delay + animation."></p>
<p>因为游戏世界是确定的，我们假设传送到服务器的输入都能够成功执行。在这种假设下，客户端能够预测游戏世界在接受输入后的状态，并且绝大部分情况下，结果是正确的。</p>
<p>与之前说的将客户端的输入发送到客户端然后等待服务器的响应再在客户端做出反应，我们可以将两者同时进行，即当在发送输入信息的时候，就当作它们已经正确执行，通常服务器返回的结果和客户端的执行的结果是一致的:</p>
<p><img src="../../assets/images/2020-02-02-net-sync-client-side-prediction-and-server-reconciliation/fpm2-03.png" alt="Animation plays while the server confirms the action."></p>
<p>现在玩家输入和运行结果之间就没有任何延迟存在了，同时服务器还是权威服务器。（如果有作弊的客户端发送无用的消息，他可以把角色放在他想要的任何地方，但这并不会影响到服务器，也就是其他玩家也不会受到他的影响）。</p>
<h2 id="PART-3-同步问题"><a href="#PART-3-同步问题" class="headerlink" title="PART 3 同步问题"></a>PART 3 同步问题</h2><p>在上面的例子里，我选用了一些比较特例的数字来让所有事情看起都很完美，现在假设另一种情况，假设现在服务器延时250ms，移动一格花费100ms，现在玩家按了两下方向键右，想要往右移动两格。</p>
<p>使用之前我们说的技术，情况如下图所示</p>
<p><img src="../../assets/images/2020-02-02-net-sync-client-side-prediction-and-server-reconciliation/fpm2-04.png" alt="Predicted state and authoritative state mismatch."></p>
<p>于是我们在 <strong>t = 250 ms</strong> 的时候就会面临一个非常 interesting 的问题，当接收到新的游戏状态时，客户端预测的位置已经到达 <strong>x = 12</strong>，但是服务器认为最新的坐标是 <strong>x = 11</strong>，因为权威服务器的缘故，客户端必须将角色移回 <strong>x = 11</strong>，但是紧接着，新的 <strong>x = 12</strong> 的状态在 <strong>t = 350</strong> 的时间到达，因此角色的位置又顺移回去了。。</p>
<p>从玩家的角度来看，他按下两次向右按钮后，角色向右移动两格，原地停留50ms后，向左顺移一格，又原地停留100ms再向右顺移一格，很明显这种情况令人难以接受。</p>
<h2 id="PART-4-服务器校对"><a href="#PART-4-服务器校对" class="headerlink" title="PART 4 服务器校对"></a>PART 4 服务器校对</h2><p>解决上面说的问题的办法就是你得意识到，客户端所看到的世界是当前的，但是因为延迟，客户端得到的游戏状态都是过去的，当服务器在发送更新的时候，它并没有把客户端发来的所有的命令都处理掉。</p>
<p>这并不是一个非常严重的问题，首先，客户端在每次请求的时候加上一个编号，在我们的例子中，第一次按键请求编号为 #1，第二次按键的请求编号为 #2。服务器回复的时候将其处理过最后一个请求的编号包含在消息中。</p>
<p><img src="../../assets/images/2020-02-02-net-sync-client-side-prediction-and-server-reconciliation/fpm2-05.png" alt="Client-side prediction + server reconciliation."></p>
<p>当t = 250的时候，服务器说“基于#1的输入请求，你的位置是11”.因为服务器是权威的，所以角色的位置是x=11， 现在假设客户端保存了一份发送到服务器的请求，基于新的游戏状态，它知道服务器已经处理了请求 #1，所以他将这个备份丢弃掉，但是客户端知道服务器还需要将#2请求的回复发过来，所以再一次进行客户端预测，客户端可以基于上次服务器发来的状态和#2输入来计算当前的状态。</p>
<p>所以当t=250ms的时候，客户端得到“经过#1的输入之后，x=11”，它将#1输入的拷贝丢弃掉，但是还有一份并没有得到服务器返回的#2的拷贝，客户端将内部游戏状态更新为服务器所发来的游戏状态，也就是x=11，然后将所有未收到回复但已经发送给服务器的输入用于预测，在上面的例子，输入就是向右移动，最终状态就是x=12，这是正确的。当t=350的时候，一个新的游戏状态从服务器获得；这种情况它说“基于#2输入，x=12”。在这是，客户端将#2请求之前的请求都丢弃，然后将游戏状态更新为x=12，没有需要预测的输入，所以不需要预测，现在得到的结果都是正确的。</p>
<p>客户端具体如何处理，这里有一个统一的处理方式：</p>
<ul>
<li>根据server的new state更新#1里的缓存状态</li>
<li>回滚input到#1，将#1之后的所有缓存的操作都应用到#1的new state中进行计算，得到最新的结果</li>
<li>客户端根据最新的结果进行更新</li>
<li>将#1的状态和input 从缓存buffer里删除</li>
</ul>
<h2 id="PART-5-误差"><a href="#PART-5-误差" class="headerlink" title="PART 5 误差"></a>PART 5 误差</h2><p>上面讨论的例子里只讨论了移动，但是这个方法在其他方面也可以使用。比如，在一个回合制的游戏里，当玩家攻击其他玩家的时候，你可以播放飙血的特效和伤害值，但是你不应该在收到服务器回复之前直接更新玩家的血量。</p>
<p>因为游戏状态的复杂性，它并不能保证是绝对可逆的，你也许希望只有再收到服务器确认的时候才将一个玩家杀死，即使这个玩家的血量降到负的了。（但假象一种情况，一个玩家实际上已经死了，但是在没有收到服务器确认之前他使用了药包，这个时候你该怎么处理？）</p>
<p>这又带来了一个有趣的问题，即使世界是绝对的确定的，并且没有玩家在作弊，还是有客户端的预测和服务器不吻合的情况。上面说的情况在单人游戏中不会出现，但是在多人接入同一个服务器的时候就会发生，这个问题会在下面的文章中进行讨论。</p>
<h2 id="PART-6-总结"><a href="#PART-6-总结" class="headerlink" title="PART 6 总结"></a>PART 6 总结</h2><p>当使用权威服务器的时候，你需要给玩家即时的响应，即使是当在等待服务器处理出入。为了达到这样的目的，客户端模拟出输入的结果，当收到服务器的回复时，客户端的游戏状态需要通过服务器的回复和还未处理的输入进行重新计算。</p>
<ul>
<li><a href="http://www.gabrielgambetta.com/client-side-prediction-server-reconciliation.html" target="_blank" rel="noopener">http://www.gabrielgambetta.com/client-side-prediction-server-reconciliation.html</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.igiven.com/dotnet-2020-02-02-net-sync-entity-interpolation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="zhepama">
      <meta itemprop="description" content="一个不专业的程序员,写着不专业的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="IGiven">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/dotnet-2020-02-02-net-sync-entity-interpolation/" class="post-title-link" itemprop="url">快节奏多人游戏同步(3)-Entity插值</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-02-02 08:00:00" itemprop="dateCreated datePublished" datetime="2020-02-02T08:00:00+08:00">2020-02-02</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2020-07-16 12:44:43" itemprop="dateModified" datetime="2020-07-16T12:44:43+08:00">2020-07-16</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/dotnet/" itemprop="url" rel="index"><span itemprop="name">dotnet</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="PART-1-概述"><a href="#PART-1-概述" class="headerlink" title="PART 1 概述"></a>PART 1 概述</h2><p>在本系列的「第一篇文章」中，我们介绍了关于权威服务器及其反作弊特性，然而仅仅是最简单的实现可能会导致关于可玩性和响应速度的问题。在「第二篇文章」中，我们提出了「客户端预测」的方案来克服这个困难。</p>
<p>以上两篇文章事实上介绍的是一种在连接到有传输延迟的远程权威服务器的状况下，可以让玩家像单机游戏一样流畅的控制角色移动的一种概念和技术。</p>
<p>在本文中，我们将会讨论在在同一台服务器上有「其他玩家控制的角色」的情况。</p>
<h2 id="PART-2-服务器-time-step"><a href="#PART-2-服务器-time-step" class="headerlink" title="PART 2 服务器 time step"></a>PART 2 服务器 time step</h2><p>在之前的文章中，我们的服务器的实现非常简单，它负责处理客户端的输入并更新游戏状态，最后将结果发送回客户端。如果有多个玩家在一起玩，那服务端主循环的逻辑有所不同了。<br>在接下来的场景中，几个客户端玩家会同时发送数据，玩家发出操作指令会非常频繁（高APM的玩家，一秒钟可能发出10个以上的操作指令），如果服务端每收到某个玩家的一条指令，就去执行input逻辑，然后广播游戏状态，这样的性能是非常差的，会消耗很多的cpu和bandwidth。<br>一个更好的办法是，利用一个queue，将客户端的输入信息缓存起来，在服务端，游戏状态以一定的频率(例如100ms一次)进行更新，每次更新的时间间隔(100ms)，就被称之为time step。<br>在每个更新循环迭代中，服务端处理queue里面所有的input，然后逐个进行计算，将最后计算的结果更新到所有客户端。<br>总体来说，整个游戏世界的更新和客户端的输入频率、数量是相对独立的，它的更新频率也是可控的。</p>
<h2 id="PART-3-低频更新处理"><a href="#PART-3-低频更新处理" class="headerlink" title="PART 3 低频更新处理"></a>PART 3 低频更新处理</h2><p>从客户端来看，这个方法运行的很平滑，客户端的预测行为独立于服务端的更新，所以它依然可以使用预测技术。不过，由于真个游戏世界的状态以一个比较低的频率进行更新，那么本地客户端对其他玩家知道的信息就很少了，信息越少的话，其他玩家的行为动作要模拟的话，就不会很准确。<br>本地客户端收到其他玩家更新坐标的消息，如何进行处理呢，有一个最简单的办法就是，每次直接使用收到的坐标进行更新，但这样看起来会有抖动，每100ms更新一次坐标，就得抖动一次，如下图所示：</p>
<p><img src="../../assets/images/2020-02-02-net-sync-entity-interpolation/fpm3-01.png" alt="Client 1 as seen by Client 2."></p>
<p>对Client2来说，Client1的位置最开始再p(10,10)，不一会直接跳到p(11,10)，100ms后又跳到(12,0)，这样的体验是很差的。那么，如何改善游戏体验呢？ 针对不同的游戏，有不同的处理方式，一般来说，客户端的行为越方便预测，就越容易做平滑处理。</p>
<h2 id="PART-4-航位推测法"><a href="#PART-4-航位推测法" class="headerlink" title="PART 4 航位推测法"></a>PART 4 航位推测法</h2><p>假设你在玩赛车游戏。一辆速度非常快的汽车是可以预测的——例如，如果它以每秒100米的速度行驶，一秒钟后，它将比它开始行驶的地方提前大约100米。</p>
<p>为什么是大约呢？在那一秒内，汽车可能加速或减速了一点，或者向右或向左转了一点——这里的关键词是“一点”。汽车的机动性是这样的：在高速行驶时，无论玩家实际做什么，其在任何时间点的位置都高度依赖于其先前的位置、速度和方向。换句话说，赛车不能立即进行180度转弯。</p>
<p>对于每100毫秒发送一次更新的服务器，这是如何工作的？客户端接收到服务器发送来的每个其他车的速度和行驶方向；在接下来的100毫秒内，它不会接收到任何新信息，但仍需要显示它们的运行情况。要做的最简单的事情是假设汽车的航向和加速度在100毫秒内保持不变，并使用该参数在本地运行汽车物理。然后，100毫秒后，当服务器更新到达时，汽车的位置被修正。</p>
<p>根据许多因素，校正可以是大的或相对小的。如果玩家把车保持在直线上，并且不改变车速，那么预测的位置将与修正的位置完全相同。另一方面，如果玩家撞到什么东西，预测的位置将是非常错误的。</p>
<p>请注意，推算定位可以应用于低速情况，例如战列舰。实际上，“dead reckoning”一词起源于航海。</p>
<h2 id="PART-5-实体插值"><a href="#PART-5-实体插值" class="headerlink" title="PART 5 实体插值"></a>PART 5 实体插值</h2><p>有许多情况航位推是没法处理的 - 对于玩家的方向和速度可以瞬间改变的都不行，比如3D射击，玩家经常快速跑动，停下，快速转向等，在这种情况下，航位推算法就非常无力了。因为位置和速度和前面的数据无关。</p>
<p>你可以选择在接到服务器的请求的时候直接更新玩家的位置，而客户端看到的就是网上其他的玩家每100ms跳一下，感觉会非常奇怪。</p>
<p>你现在拥有的是每100ms由服务器传送过来的权威数据，现在要做的是如何在这100ms内让网络角色看起来非常自然，解决问题的关键就是将网络玩家显示在过去的某个时刻。</p>
<p>假设你在t=1000收到位置信息，你已经在t=900收到了一次位置信息，所以你知道玩家在t=900和t=1000的位置，所以在t=1000到t=1100之间，你只要显示玩家t=900到t=1000的位置。这种方法，你所显示的都是玩家的真实数据，只是有100ms的延迟。</p>
<p><img src="../../assets/images/2020-02-02-net-sync-entity-interpolation/fpm3-02.png" alt="Client 2 renders Client 1 in the past, interpolating last known positions."></p>
<p>用来插值的t=900和t=1000的数据依赖于游戏。插值通常都可以处理得很好。如果不是这种方法，你可能需要服务器发送更加详细的移动信息了 - 比如更多的位置采样点，或者每10ms发送一次(你不必发十倍的数据 - 因为你发的微小的位移数据，在这种情况下数据的格式可以很好的优化一下)。</p>
<p>当使用这种技术的时候，每一个玩家都和游戏世界有一点点不同步，因为每个玩家看到自己的世界是当前的，但是其他的玩家都是过去的。但即使是快速的游戏，这100ms的延迟都不是那么明显。</p>
<p>有一种情况除外 - 当你需要时间和空间的准确性的时候，比如一个玩家射击另一个玩家的时候，因为其他的玩家都是存在于过去的某个时候，你的瞄准其实是有100ms的延迟的 - 也就是说，你设计的目标是100ms的某个目标！ 这个问题我们下一篇会进行讨论。</p>
<h2 id="PART-6-总结"><a href="#PART-6-总结" class="headerlink" title="PART 6 总结"></a>PART 6 总结</h2><p>在权威服务器的环境中，有着不确定的服务器更新和网络延迟，在这种情况下你还要给玩家平滑的移动。在第二篇中，我们展示了一种客户端预测和服务器调和的技术，来实现实时的角色控制，这样的方案让玩家能够得到即时的反馈，移除了致命的延迟。</p>
<p>其他玩家的同步还是一个问题，但是，在这篇文章中，我们提出了两种解决方案。</p>
<p>第一种是航位推技术，这种模拟需要entity的位置能够通过前一个时候的位置，速度，加速度来推算出来，当不满足这种情况的时候，航位推就没用了。</p>
<p>第二种是插值技术，不预测将来的位置，只是使用服务器传来的数据，这种就会造成显示的entity总是过去的某个时刻。最后的结果就是玩家的角色总是当前时刻，而其他看到的entity都是过去的某个时刻，这种情况可以产生一种难以置信的无缝体验。</p>
<p>但是，当游戏需要高速离散的准确性的时候，比如射击或者移动物体，美景就破灭了：你看其他玩家的位置和服务器的位置不一致，别的玩家看你的位置也不是正确的，这样爆头就不可能发生了！很多游戏都有爆头这一说，我们将在下面的文章中来讨论这个问题。</p>
<ul>
<li><a href="http://www.gabrielgambetta.com/entity-interpolation.html" target="_blank" rel="noopener">http://www.gabrielgambetta.com/entity-interpolation.html</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/3/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><span class="page-number current">4</span><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><a class="extend next" rel="next" href="/page/5/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">zhepama</p>
  <div class="site-description" itemprop="description">一个不专业的程序员,写着不专业的博客</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">81</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/zhepama" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;zhepama" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zhepama@gmail.com" title="E-Mail → mailto:zhepama@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>


  <div class="links-of-blogroll motion-element">
    <div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i>
      Links
    </div>
    <ul class="links-of-blogroll-list">
        <li class="links-of-blogroll-item">
          <a href="http://www.godgodgame.com/" title="http:&#x2F;&#x2F;www.godgodgame.com" rel="noopener" target="_blank">GODGODGAME</a>
        </li>
        <li class="links-of-blogroll-item">
          <a href="https://www.igiven.com/" title="https:&#x2F;&#x2F;www.igiven.com">IGIVEN</a>
        </li>
    </ul>
  </div>

      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhepama</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
